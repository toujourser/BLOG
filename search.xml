<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Zookeeper]]></title>
    <url>%2Fblog%2F2018%2F01%2F23%2FZookeeper%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Apache顶级项目。Yahoo借鉴了Chubby的思想开发了ZooKeeper并开源。 1234567891011121314151617181920212223242526272829303132333435# yum install jdk-8u191-linux-x64.rpm运行java命令成功看到java版本号，就可以使用zk了# java -versionjava version "1.8.0_191"Java(TM) SE Runtime Environment (build 1.8.0_191-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)!!!!!!重要JAVA配置，JDK要求1.6以上# vim /etc/profile.d/jdk.shexport JAVA_HOME=/usr/java/defaultexport PATH=$JAVA_HOME/bin:$PATH主机名解析设置此主机名为nodex，配置hosts文件# vi /etc/hosts192.168.142.140 nodex创建hadoop用户# useradd hadoop# echo hadoop | passwd hadoop --stdinChanging password for user hadoop.passwd: all authentication tokens updated successfully.-----------------------------------------------------注意，下面使用hadoop用户登录操作$ tar xf zookeeper-3.4.12.tar.gz$ mv zookeeper-3.4.12 zookeeper$ mv zookeeper ~/增加环境变量$ vim ~/.bash_profile$ cat ~/.bash_profileexport ZOOKEEPER_HOME=/home/hadoop/zookeeperexport PATH=$PATH:$ZOOKEEPER_HOME/bin 配置文件 12345conf目录下提供了样例配置文件zoo_sample.cfg$ cd zookeeper/conf$ lsconfiguration.xsl log4j.properties zoo_sample.cfg$ cat zoo_sample.cfg Standalone单机模式单机模式只适合用于测试，略过。 伪集群模式伪分布式集群的配置文件稍作改动，就可以成为分布式集群。准备 123456$ mkdir -p ~/mds/zk/&#123;data&#123;1,2,3&#125;,log&#123;1,2,3&#125;&#125;!!!!!!!!!!!!!!重要，构建myid文件$ touch ~/mds/zk/data&#123;1,2,3&#125;/myid$ echo 1 &gt; ~/mds/zk/data1/myid$ echo 2 &gt; ~/mds/zk/data2/myid$ echo 3 &gt; ~/mds/zk/data3/myid 配置文件 1234567891011121314151617181920212223242526272829303132333435363738zoo1.cfg如下tickTime=2000initLimit=10syncLimit=5dataDir=/home/hadoop/mds/zk/data1dataLogDir=/home/hadoop/mds/zk/log1clientPort=2181server.1=nodex:2887:3887server.2=nodex:2888:3888server.3=nodex:2889:3889zoo2.cfg如下tickTime=2000initLimit=10syncLimit=5dataDir=/home/hadoop/mds/zk/data2dataLogDir=/home/hadoop/mds/zk/log2clientPort=2182server.1=nodex:2887:3887server.2=nodex:2888:3888server.3=nodex:2889:3889zoo3.cfg如下tickTime=2000initLimit=10syncLimit=5dataDir=/home/hadoop/mds/zk/data3dataLogDir=/home/hadoop/mds/zk/log3clientPort=2183server.1=nodex:2887:3887server.2=nodex:2888:3888server.3=nodex:2889:3889 clientPort 客户端通信端口 dataDir zk的数据目录，持久化内存数据的目录，快照 dataLogDir 顺序日志存储目录 tickTime 滴答声，以后凡是用到时间都是以这个时间间隔tick为单位，本例中，设定时间1个tick是2000毫秒 initLimit=10 Follower到Leader初始化连接的忍受的最长时间间隔，2000ms*10=20s syncLimit=5 Follower和Leader之间通信，请求和应答的时间上限为5个tick间隔 server.1=nodex:2887:3887 server.x，x是每一个server的myid nodex必须是每一个主机都能解析的主机名，可以用ip 2887，Follower和Leader之间通信端口 3887，选举用端口 | 启动服务注意：如果启动失败，可能是JAVA_HOME、myid等环境变量未设置 1234567891011121314151617181920212223242526建议第一次启动使用前台启动，看看有没有问题，可以在控制台看见异常信息$ zkServer.sh start-foreground zookeeper/conf/zoo1.cfg后台启动其他服务，如有必要请前台启动以便查错$ zkServer.sh start zookeeper/conf/zoo2.cfg$ zkServer.sh start zookeeper/conf/zoo2.cfg默认连接本地2181端口zkCli.sh -server host:port 连接到指定的服务器$ zkCli.sh -server nodex:2183ls 查看节点ls path [watch]ls2 查看节点和信息ls2 path [watch]get 获取节点的信息get path [watch]create 创建path，设置数据create [-s] [-e] path data acldelete 删除pathdelete path [version][zk: nodex:2183(CONNECTED) 0] ls[zk: nodex:2183(CONNECTED) 1] ls /[zookeeper][zk: nodex:2183(CONNECTED) 2] ls /zookeeper 角色 在Zk集群中必须通过选举选出master，这个master就是Leader。 角色 功能 Leader 负责投票的发起和决议，更新系统状态。Leader数据是最新的、最权威的。 Follower 接受客户端读请求并返回结果，写请求转给Leader。参与选主投票 Observer 接受客户端读请求并返回结果，写请求发给Leader。不参与投票。扩展节点，减轻读压力 Client 读写请求的发起方 一旦Leader产生，其他的节点加入只能成为Follower。Follower有投票权。新增的Observer，等同于没有投票权的Follower。 每一个中Server都可以读取到数据，但写请求需要转给Leader。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy]]></title>
    <url>%2Fblog%2F2018%2F01%2F11%2FScrapy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Scrapy是用Python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘、信息处理或存储历史数据等一系列的程序中。Scrapy使用Twisted基于事件的高效异步网络框架来处理网络通信，可以加快下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。 Scrapy架构 Scrapy Engine引擎，负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。 此组件相当于爬虫的“大脑”，是整个爬虫的调度中心。 调度器(Scheduler)调度器接收从引擎发送过来的request，并将他们入队，以便之后引擎请求他们时提供给引擎。初始的爬取URL和后续在页面中获取的待爬取的URL将放入调度器中，等待爬取。同时调度器会自动去除重复的URL（如果特定的URL不需要去重也可以通过设置实现，如post请求的URL） 下载器(Downloader)下载器负责获取页面数据并提供给引擎，而后提供给spider。 Spiders爬虫Spider是编写的类，作用如下：Scrapy用户编写用于分析response并提取item(即获取到的item)额外跟进的URL，将额外跟进的URL提交给引擎，加入到Scheduler调度器中。将每个spider负责处理一个特定(或一些)网站。 Item PipelineItem Pipeline负责处理被spider提取出来的item。典型的处理有清理、 验证及持久化(例如存取到数据库中)。当页面被爬虫解析所需的数据存入Item后，将被发送到项目管道(Pipeline)，并经过设置好次序的pipeline程序处理这些数据，最后将存入本地文件或存入数据库。 以下是item pipeline的一些典型应用： 清理HTML数据 验证爬取的数据(检查item包含某些字段) 查重(或丢弃) 将爬取结果保存到数据库中 下载器中间件(Downloader middlewares)简单讲就是自定义扩展下载功能的组件下载器中间件，是在引擎和下载器之间的特定钩子(specific hook)，处理它们之间的请求request和响应response。 它提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。通过设置下载器中间件可以实现爬虫自动更换user-agent、IP等功能。 Spider中间件(Spider middlewares)Spider中间件，是在引擎和Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items或requests)。 也提供了同样的简便机制，通过插入自定义代码来扩展Scrapy功能。 数据流(Data flow) 引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个（批）要爬取的 URL(s) 引擎从Spider中获取到第一个要爬取的URL并加入到调度器(Scheduler)作为请求以备调度 引擎向调度器请求下一个要爬取的URL 调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件并转发给下载器(Downloader) 一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件发送给引擎 引擎从下载器中接收到Response，然后通过Spider中间件发送给Spider处理 Spider处理Response并返回提取到的Item及(跟进的)新的Request给引擎 引擎将Spider返回的Item交给Item Pipeline，将Spider返回的Request交给调度器 (从第二步)重复执行，直到调度器中没有待处理的request，引擎关闭 注意：只有当调度器中没有任何request了，整个程序才会停止执行。如果有下载失败的URL，会重新下载 安装scrapy12345678安装wheel支持$ pip install wheel安装scrapy框架$ pip install scrapywindow下，为了避免windows编译安装twisted依赖，安装下面的二进制包$ pip install Twisted-18.4.0-cp35-cp35m-win_amd64.whl 1234567891011121314windows下出现如下问题copying src\twisted\words\xish\xpathparser.g -&gt; build\lib.win-amd64-3.5\twisted\words\xishrunning build_extbuilding 'twisted.test.raiser' extensionerror: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ BuildTools": http://landinghub.visualstudio.com/visual-cpp-build-tools解决方案是，下载编译好的twisted，https://www.lfd.uci.edu/~gohlke/pythonlibs/#twistedpython3.5 下载 Twisted-18.4.0-cp35-cp35m-win_amd64.whlpython3.6 下载 Twisted-18.4.0-cp36-cp36m-win_amd64.whl安装twisted$ pip install Twisted-18.4.0-cp35-cp35m-win_amd64.whl之后在安装scrapy就没有什么问题了 安装好，使用scrapy命令看看 123456789101112131415161718192021&gt; scrapyScrapy 1.5.0 - no active projectUsage: scrapy &lt;command&gt; [options] [args]Available commands: bench Run quick benchmark test check Check spider contracts crawl Run a spider edit Edit spider fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates list List available spiders parse Parse URL (using its spider) and print the results runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy 项目编写流程 创建项目 使用 scrapy startproject proname 创建一个scrapy项目 编写item 在items.py中编写Item类，明确从response中提取的item 编写爬虫 编写spiders/proname_spider.py，即爬取网站的spider并提取出item 编写item pipeline item的处理，可以存储]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 笔记]]></title>
    <url>%2Fblog%2F2017%2F11%2F25%2FReact%20%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介React是Facebook开发并开源的前端框架。当时他们的团队在市面上没有找到合适的MVC框架，就自己写了一个Js框架，用来架设Instagram（图片分享社交网络）。2013年React开源。React解决的是前端MVC框架中的View视图层的问题。 Virtual DOMDOM（文档对象模型Document Object Model） 将网页内所有内容映射到一棵树型结构的层级对象模型上，浏览器提供对DOM的支持，用户可以是用脚本调用DOM API来动态的修改DOM结点，从而达到修改网页的目的，这种修改是浏览器中完成，浏览器会根据DOM的改变重绘改变的DOM结点部分。 修改DOM重新渲染代价太高，前端框架为了提高效率，尽量减少DOM的重绘，提出了Virtual DOM，所有的修改都是现在Virtual DOM上完成的，通过比较算法，找出浏览器DOM之间的差异，使用这个差异操作DOM，浏览器只需要渲染这部分变化就行了。React实现了DOM Diff算法可以高效比对Virtual DOM和DOM的差异。 支持JSX语法JSX是一种JavaScript和XML混写的语法，是JavaScript的扩展。 12345678React.render( &lt;div&gt; &lt;div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;, document.getElementById('example')); 程序解释import React from &#39;react&#39;;导入react模块import ReactDOM from &#39;react-dom&#39;;导入react的DOM模块class Root extends React.Component组件类定义，从React.Component类上继承。这个类生成JSXElement对象即React元素。render()渲染函数。返回组件中渲染的内容。注意，只能返回唯一 一个顶级元素回去。ReactDom.render(&lt;Root/&gt;, document.getElementById(&#39;root&#39;));第一个参数是JSXElement对象，第二个是DOM的Element元素。将React元素添加到DOM的Element元素中并渲染。还可以使用React.createElement创建react元素，第一参数是React组件或者一个HTML的标签名称（例如div、span）。 注意：1、React组件的render函数return，只能是一个顶级元素2、JSX语法是XML，要求所有元素必须闭合，注意&lt;br /&gt; 不能写成&lt;br&gt; JSX规范 约 定标签中首字母小写就是html标记，首字母大写就是组件 要求严格的HTML标记，要求所有标签都必须闭合。br也应该写成 &lt;br /&gt; ，/前留一个空格。 单行省略小括号，多行请使用小括号 元素有嵌套，建议多行，注意缩进 JSX表达式：表达式使用{}括起来，如果大括号内使用了引号，会当做字符串处理，例如 {‘2&gt;1?true:false’} 里面的表达式成了字符串了 组件状态state每一个React组件都有一个状态属性state，它是一个JavaScript对象，可以为它定义属性来保存值。如果状态变化了，会触发UI的重新渲染。使用setState()方法可以修改state值。注意：state是每个组件自己内部使用的，是组件自己的属性。 HTML DOM的JavaScript事件 使用React实现传统的HTML 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;);&#125;render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.baidu', p2: '.com' &#125;; // 构造函数中定义state render() &#123; // this.state.p1 = 'python.baidu'; // 可以修改属性值 // this.setState(&#123;p1:'python.baidu'&#125;); // 不可以对还在更新中的state使用setState // Warning: setState(...): Cannot update during an existing state transition (such as within render). setTimeout(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); // setInterval(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 分析Toggle类它有自己的state属性。当render完成后，网页上有一个div标签，div标签对象捆绑了一个click事件的处理函数，div标签内有文本内容。如果通过点击左键，就触发了click方法关联的handleClick函数，在这个函数里将状态值改变。状态值state的改变将引发render重绘。如果组件自己的state变了，只会触发自己的render方法重绘。 注意：{this.handleClick.bind(this)}，不能外加引号this.handleClick.bind(this)一定要绑定this，否则当触发捆绑的函数时，this是函数执行的上下文决定的，this已经不是触发事件的对象了。console.log(event.target.id)，取回的产生事件的对象的id，但是这不是我们封装的组件对象。所以，console.log(event.target===this)是false。所以这里一定要用this，而这个this是通过绑定来的。 React中的事件 使用小驼峰命名 使用JSX表达式，表达式中指定事件处理函数 不能使用return false，如果要阻止事件默认行为，使用event.preventDefault() 属性props **props就是组件的属性properties。把React组件当做标签使用，可以为其增加属性，如下&lt;Toggle name=&quot;school&quot; parent={this} /&gt;为上面的Toggle元素增加属性：1、 name = “school” ，这个属性会作为一个单一的对象传递给组件，加入到组件的props属性中2、 parent = {this} ，注意这个this是在Root元素中，指的是Root组件本身3、在Root中为使用JSX语法为Toggle增加子元素，这些子元素也会被加入Toggle组件的props.children中 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1 + this.props.parent.state.p2&#125;&lt;br /&gt; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.baidu', p2: '.com' &#125;; // 构造函数中定义state render() &#123; render). setTimeout(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); // setInterval(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 尝试修改props中的属性值，会抛出TypeError: Cannot assign to read only property &#39;name&#39; of object &#39;#\&lt;Object&gt;&#39; 异常。 应该说，state是私有private的属于组件自己的属性，组件外无法直接访问。可以修改state，但是建议使用setState方法。props是公有public属性，组件外也可以访问，但只读。 构造器constructor使用ES6的构造器，要提供一个参数props，并把这个参数使用super传递给父类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; constructor (props) &#123; super(props); // 一定要调用super父类构造器，否则报错 this.state = &#123; flag: true &#125;; // 类中定义state &#125; handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1 + this.props.parent.state.p2&#125;&lt;br /&gt; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 constructor(props) &#123; super(props); // 一定要调用super父类构造器，否则报错 this.state = &#123; p1: 'www.baidu', p2: '.com' &#125;; // 构造函数中定义state &#125; render() &#123; // this.state.p1 = 'python.baidu'; // 可以修改属性值 setTimeout(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); // setInterval(() =&gt; this.setState(&#123; p1: 'python.baidu' &#125;), 5000); return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 组件的生命周期组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 组件的生命周期状态，说明在不同时机访问组件，组件正处在生命周期的不同状态上。在不同的生命周期状态访问，就产生不同的方法。 生命周期的方法如下： 装载组件触发componentWillMount 在渲染前调用，在客户端也在服务端。只会在装载之前调用一次。componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。只在装载完成后调用一次，在render之后。 更新组件触发。这些方法不会在首次render组件的周期调用 componentWillReceiveProps(nextProps) 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。 shouldComponentUpdate(nextProps, nextState) 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。 可以在你确认不需要更新组件时使用。 如果设置为false，就是不允许更新组件，那么componentWillUpdate、componentDidUpdate不会执行。 componentWillUpdate(nextProps, nextState) 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate(prevProps, prevState) 在组件完成更新后立即调用。在初始化时不会被调用。 卸载组件触发 componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。 无状态组件React从15.0开始支持无状态组件，定义如下 1234567import React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;function Root(props) &#123; return &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;&#125;ReactDom.render(&lt;Root schoolName=&quot;baidu&quot; /&gt;, document.getElementById(&apos;root&apos;)); 无状态组件，也叫函数式组件。开发中，很多情况下，组件其实很简单，不需要state状态，也不需要使用生命周期函数。无状态组件很好的满足了需要。无状态组件函数应该提供一个参数props，返回一个React元素。无状态组件函数本身就是render函数。 改写上面的代码 1234import React from &apos;react&apos;;import ReactDom from &apos;react-dom&apos;;let Root = props =&gt; &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;ReactDom.render(&lt;Root schoolName=&quot;baidu&quot; /&gt;, document.getElementById(&apos;root&apos;));]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元编程]]></title>
    <url>%2Fblog%2F2017%2F10%2F06%2F%E5%85%83%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[元编程概念来自LISP和smalltalk。 我们写程序是直接写代码，是否能够用代码来生成未来我们需要的代码吗？这就是元编程 用来生成代码的程序称为元程序metaprogram，编写这种程序就称为元编程metaprogramming Python语言能够通过反射实现元编程。 Python中 所有非object类都继承自object类 所有类的类型包括type类都是type type类继承自object类，object类的类型也是type类 type类type构建类12345678910class type(object): def __init__(cls, what, bases=None, dict=None): # known special case of type.__init__ """ type(object_or_name, bases, dict) type(object) -&gt; the object's type type(name, bases, dict) -&gt; a new type # (copied from class doc) """ pass type(object) -&gt; the object&#39;s type ，返回对象的类型，例如type(10)type(name, bases, dict) -&gt; a new type 返回一个新的类型 123456XClass = type('myclass', (object,), &#123;'a':100, 'b':'string'&#125;) # 字典是类属性print(XClass)print(XClass.__dict__)print(XClass.__name__)print(XClass.__bases__)print(XClass.mro()) 上例并不稀奇，我们用它创建更加复杂的类 12345678910111213def __init__(self): self.x = 1000 def show(self): print(self.__dict__) XClass = type('myclass', (object,), &#123;'a':100, 'b': 'string', 'show':show, '__init__':__init__&#125;)print(XClass)print(XClass.__name__)print(XClass.__dict__)print(XClass.mro())XClass().show() 可以借助type构造任何类，用代码来生成代码，这就是元编程。 构建元类一个类可以继承自type类。注意不是继承自object类了 123456class ModelMeta(type): def __new__(cls, *args, **kwargs): print(cls) print(args) print(kwargs) return super().__new__(cls, *args,**kwargs) 继承自type，ModelMeta就是元类，它可以创建出其它类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ModelMeta(type): # 继承自type def __new__(cls, *args, **kwargs): print(cls) print(args) print(kwargs, '-------------') return super().__new__(cls, *args, **kwargs)# 第一种 使用metaclass关键字参数指定元类class A(metaclass=ModelMeta): id = 100 def __init__(self): print('~~A.init~~') # 第二种 B继承自A后，依然是从ModelMeta的类型class B(A): def __init__(self): print('~~B.init~~') # 第三种 元类就可以使用下面的方式创建新的类C = ModelMeta('C', (), &#123;&#125;)# D、E是type的实例class D:pass # D = type('D', (), &#123;&#125;)E = type('E', (), &#123;&#125;)class F(ModelMeta):passprint('~~~~~~~~~~~~')print(type(A))print(type(B))print(type(C))print(type(D))print(type(E))print(type(F))# 打印输出&lt;class '__main__.ModelMeta'&gt;('A', (), &#123;'__module__': '__main__', '__qualname__': 'A', 'id': 100, '__init__': &lt;functionA.__init__ at 0x000001CC53E37840&gt;&#125;)&#123;&#125; -------------&lt;class '__main__.ModelMeta'&gt;('B', (&lt;class '__main__.A'&gt;,), &#123;'__module__': '__main__', '__qualname__': 'B', '__init__':&lt;function B.__init__ at 0x000001CC53E378C8&gt;&#125;)&#123;&#125; -------------&lt;class '__main__.ModelMeta'&gt;('C', (), &#123;&#125;)&#123;&#125; -------------~~~~~~~~~~~~&lt;class '__main__.ModelMeta'&gt;&lt;class '__main__.ModelMeta'&gt;&lt;class '__main__.ModelMeta'&gt;&lt;class 'type'&gt;&lt;class 'type'&gt;&lt;class 'type'&gt; 从运行结果还可以分析出 __new__(cls, *args, **kwargs) 的参数结构中间是一个元组(&#39;A&#39;, (), {&#39;__init__&#39;: &lt;function A.__init__ at 0x0000000000B6E598&gt;, &#39;__module__&#39;:&#39;__main__&#39;, &#39;__qualname__&#39;: &#39;A&#39;, &#39;id&#39;: 100})对应 (name, bases, dict)修改代码如下 1234567class ModelMeta(type): # 继承自type def __new__(cls, name, bases, dict): print(cls) print(name) print(bases) print(dict, '-------------') return super().__new__(cls, name, bases, dict) 从运行结果可以看出，只要元类是ModelMeta，创建类对象时，就会调用ModelMeta的new方法 元类的应用1234567891011121314151617181920212223242526272829303132333435363738394041class Field: def __init__(self, fieldname=None, pk=False, nullable=True): self.fieldname = fieldname self.pk = pk self.nullable = nullable def __repr__(self): return "&lt;Field &#123;&#125;&gt;".format(self.fieldname) class ModelMeta(type): # 继承自type def __new__(cls, name, bases, attrs:dict): print(cls) print(name) print(bases) print(attrs, '-------------') if '__tablename__' not in attrs.keys(): attrs['__tablename__'] = name primarykeys = [] for k,v in attrs.items(): if isinstance(v, Field): if v.fieldname is None: v.fieldname = k # 没有名字则使用属性名 if v.pk: primarykeys.append(v) attrs['__primarykeys__'] = primarykeys return super().__new__(cls, name, bases, attrs)class ModelBase(metaclass=ModelMeta): '''从ModelBase继承的类的类型都是ModelMeta''' passclass Student(ModelBase): id = Field(pk=True, nullable=False) name = Field('username', nullable=False) age = Field() print('----------------')print(Student.__dict__) 元编程总结元类是制造类的工厂，是生成类的类。构造好元类，就可以在类定义时，使用关键字参数metaclass指定元类，可以使用最原始的metatype(name,bases, dict)的方式构造一个类。元类的 __new__()方法中，可以获取元类信息、当前类、基类、类属性字典。 元编程一般用于框架开发中。 开发中除非你明确的知道自己在干什么，否则不要随便使用元编程99%的情况下用不到元类，可能有些程序员一辈子都不会使用元类 Django、SQLAlchemy使用了元类，让我们使用起来很方便。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS对象模型]]></title>
    <url>%2Fblog%2F2017%2F10%2F06%2FJS%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS对象模型 JavaScript 是一种基于原型（Prototype）的面向对象语言，而不是基于类的面向对象语言。C++、Java有类Class和实例Instance的概念，类是一类事物的抽象，而实例则是类的实体。 JS是基于原型的语言，它只有原型对象的概念。原型对象就是一个模板，新的对象从这个模板构建从而获取最初的属性。任何对象在运行时可以动态的增加属性。而且，任何一个对象都可以作为另一个对象的原型，这样后者就可以共享前者的属性。 定义类字面式声明方式1234567891011121314var obj = &#123; property_1: value_1, // property_# may be an identifier... property_2: value_2, // or a number... ..., "property n": value_n // or a string&#125;;var obj = &#123; x : 1, 1 : 'abc', 'y':'123'&#125;for (let s in obj) console.log(s, typeof(s)); 这种方法也称作字面值创建对象。Js 1.2开始支持。 ES6之前——构造器1、定义一个函数（构造器）对象，函数名首字母大写2、使用this定义属性3、使用new和构造器创建一个新对象 1234567891011121314151617181920212223// 定义类，构造器function Point(x, y) &#123; this.x = x; this.y = y; this.show = () =&gt; &#123;console.log(this,this.x,this.y)&#125;; console.log('Point~~~~~~~~');&#125;console.log(Point);p1 = new Point(4,5);console.log(p1);console.log('----------------');// 继承function Point3D(x,y,z) &#123; Point.call(this,x,y); // "继承" this.z = z; console.log('Point3D~~~~~~~~');&#125;console.log(Point3D);p2 = new Point3D(14,15,16);console.log(p2);p2.show(); new 构建一个新的通用对象，new操作符会将新对象的this值传递给Point3D构造器函数，函数为这个对象创建z属性。从上句话知道，new后得到一个对象，使用这个对象的this来调用构造器，那么如何执行“基类”的构造器方法呢？使用Point3D对象的this来执行Point的构造器，所以使用call方法，传入子类的this。最终，构造完成后，将对象赋给p2。 注意：如果不使用new关键字，就是一次普通的函数调用，this不代表实例。 ES6中的class从ES6开始，新提供了class关键字，使得创建对象更加简单、清晰。1、类定义使用class关键字。创建的本质上还是函数，是一个特殊的函数2、一个类只能拥有一个名为constructor的构造器方法。如果没有显式的定义一个构造方法，则会添加一个默认的constuctor方法。3、继承使用extends关键字4、一个构造器可以使用super关键字来调用一个父类的构造函数5、类没有私有属性 12345678910111213141516171819202122// 基类定义class Point &#123; constructor(x,y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this,this.x,this.y); &#125;&#125;let p1 = new Point(10,11)p1.show()// 继承class Point3D extends Point &#123; constructor (x,y,z) &#123; super(x,y); this.z = z; &#125;&#125;let p2 = new Point3D(20,21,22);p2.show() 重写方法子类Point3D的show方法，需要重写 123456789101112131415161718192021222324252627// 基类定义class Point &#123; constructor(x,y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this,this.x,this.y); &#125;&#125;let p1 = new Point(10,11)p1.show()// 继承class Point3D extends Point &#123; constructor (x,y,z) &#123; super(x,y); this.z = z; &#125; show()&#123; // 重写 console.log(this,this.x,this.y, this.z); &#125;&#125;let p2 = new Point3D(20,21,22);p2.show(); 子类中直接重写父类的方法即可。如果需要使用父类的方法，使用super.method()的 方式调用。使用箭头函数重写上面的方法 12345678910111213141516171819202122// 基类定义// 基类定义class Point &#123; constructor(x,y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = function () &#123;console.log(this,this.x,this.y)&#125;; this.show = () =&gt; console.log('Point'); &#125;&#125;// 继承class Point3D extends Point &#123; constructor (x,y,z) &#123; super(x,y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20,21,22);p2.show(); // Point3D 从运行结果来看，箭头函数也支持子类的覆盖 12345678910111213141516171819202122232425// 基类定义class Point &#123; constructor(x,y) /*构造器*/ &#123; this.x = x; this.y = y; this.show = () =&gt; console.log('Point'); &#125; // show() /*方法*/ &#123; // console.log(this,this.x,this.y); // &#125;&#125;// 继承class Point3D extends Point &#123; constructor (x,y,z) &#123; super(x,y); this.z = z; //this.show = () =&gt; console.log('Point3D'); &#125; show()&#123; // 重写 console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20,21,22);p2.show(); // Point 上例优先使用了父类的属性show 123456789101112131415161718192021// 基类定义class Point &#123; constructor(x,y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = () =&gt; console.log('Point'); &#125; show() /*方法*/ &#123; console.log(this,this.x,this.y); &#125;&#125;// 继承class Point3D extends Point &#123; constructor (x,y,z) &#123; super(x,y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20,21,22);p2.show(); // Point3D 优先使用了子类的属性。总结父类、子类使用同一种方式类定义属性或者方法，子类覆盖父类。访问同名属性或方法时，优先使用属性。 静态属性静态属性目前还没有得到很好的支持。 静态方法在方法名前加上static，就是静态方法了。 123456789101112131415class Add &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static print()&#123; console.log(this.x); // ? this是什么 &#125;&#125;add = new Add(40, 50);console.log(Add);Add.print();//add.print(); // 实例不能访问直接访问静态方法，和C++、Java一致add.constructor.print(); // 实例可以通过constructor访问静态方法 静态方法中的this是Add类，而不是Add的实例 注意：静态的概念和Python的静态不同，相当于Python中的类变量。 this的坑虽然Js和 C++ 、Java一样有this，但是Js的表现是不同的。原因在于， C++ 、Java是静态编译型语言，this是编译期绑定，而Js是动态语言，运行期绑定。 1234567891011121314151617181920var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this === global); // this是否是global对象 return this.name; &#125;; &#125;&#125;;console.log(school.getNameFunc()());/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;trueundefined*/ 为了分析上面的程序，先学习一些知识：函数执行时，会开启新的执行上下文环境ExecutionContext。创建this属性，但是this是什么就要看函数是怎么调用的了。 1、myFunction(1,2,3)，普通函数调用方式，this指向全局对象。全局对象是nodejs的global或者浏览器中的window。2、myObject.myFunction(1,2,3)，对象方法的调用方式，this指向包含该方法的对象。3、call和apply方法调用，要看第一个参数是谁。 分析上例baidu 和 { name: ‘baidu’, getNameFunc: [Function: getNameFunc] } 很好理解。第三行打印的true，是 console.log(this == global) 执行的结果，说明当前是global，因为调用这个返回的函数是直接调用的，这就是个普通函数调用，所以this是全局对象。第四行undefined，就是因为this是global，没有name属性。 这就是函数调用的时候，调用方式不同，this对应的对象不同，它已经不是C++、Java的指向实例本身了。this的问题，这是历史遗留问题，新版只能保留且兼容了。而我们在使用时，有时候需要明确的让this必须是我们期望的对象，如何解决这个问题呢？ 1 显式传入12345678910111213141516171819var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function (that) &#123; console.log(this == global); // this是否是global对象 return that.name; &#125;; &#125;&#125;console.log(school.getNameFunc()(school));/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;falsebaidu*/ 通过主动传入对象，这样就避开了this的问题 2 ES3（ES-262第三版）引入了apply、call方法12345678910111213141516171819var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc().call(school)); // call方法显式传入this对应的对象/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;falsebaidu*/ apply、call方法都是函数对象的方法，第一参数都是传入对象引入的。apply传其他参数需要使用数组call传其他参数需要使用可变参数收集 12345678function Print() &#123; this.print = function(x,y) &#123;console.log(x + y)&#125;;&#125;p = new Print(1,2)p.print(10, 20)p.print.call(p, 10, 20);p.print.apply(p, [10, 20]); 3 ES5 引入了bind方法bind方法来设置函数的this值 123456789101112131415161718var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc().bind(school)); // bind方法绑定/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;[Function: bound ]*/ 只打印了三行，说明哪里有问题，问题出在bind方法用错了。 1234567891011121314151617181920212223242526var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;var func = school.getNameFunc();console.log(func);var boundfunc = func.bind(school); // bind绑定后返回新的函数console.log(boundfunc);console.log(boundfunc());/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;[Function][Function: bound ]falsebaidu*/ apply、call方法，参数不同，调用时传入this。bind方法是为函数先绑定this，调用时直接用。 4 ES6引入支持this的箭头函数ES6 新技术，就不需要兼容this问题。 12345678910111213141516171819var school = &#123; name : 'baidu', getNameFunc : function () &#123; console.log(this.name); console.log(this); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc()());/* 运行结果baidu&#123; name: 'baidu', getNameFunc: [Function: getNameFunc] &#125;falsebaidu*/ ES6 新的定义方式如下 123456789101112131415161718192021class school&#123; constructor()&#123; this.name = 'baidu'; &#125; getNameFunc() &#123; console.log(this.name); console.log(this, typeof(this)); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(new school().getNameFunc()());/* 运行结果baiduschool &#123; name: 'baidu' &#125; 'object'falsebaidu*/ 以上解决this问题的方法，bind方法最常用。 高阶对象、高阶类、或称Mixin模式Mixin模式，混合模式。这是一种不用继承就可以复用的技术。主要还是为了解决多重继承的问题。多继承的继承路径是个问题。 JS是基于对象的，类和对象都是对象模板。混合mixin，指的是将一个对象的全部或者部分拷贝到另一个对象上去。其实就是属性了。可以将多个类或对象混合成一个类或对象。 继承实现先看一个继承实现的例子 1234567891011121314151617181920class Serialization&#123; constructor()&#123; console.log('Serialization constructor~~~'); if (typeof(this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x,y)&#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125;&#125;//s = new Serialization(); // 构造Serialization失败//p = new Point(4,5); // 构造子类对象时，调用父类构造器执行也会失败 父类构造函数中，要求具有属性是stringify的序列化函数，如果没有则抛出异常。以下是完整继承的代码 1234567891011121314151617181920212223242526272829303132333435class Serialization&#123; constructor()&#123; console.log('Serialization constructor~~~'); if (typeof(this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x,y)&#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125; stringify () &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;&gt;` &#125;&#125;class Point3D extends Point &#123; constructor(x,y,z)&#123; super(x,y); this.z = z; &#125; stringify () &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;, z=$&#123;this.z&#125;&gt;` &#125;&#125;p = new Point(4,5);console.log(p.stringify())p3d = new Point3D(7,8,9);console.log(p3d.stringify()); 高阶对象实现将类的继承构建成箭头函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 普通的继承class A extends Object &#123;&#125;;console.log(A);// 匿名类const A1 = class &#123; constructor(x) &#123; this.x = x; &#125;&#125;console.log(A1);console.log(new A1(100).x);// 匿名继承const B = class extends Object&#123; constructor()&#123; super(); console.log('B constructor'); &#125;&#125;;console.log(B);b = new B();console.log(b);// 箭头函数，参数是类，返回值也是类// 把上例中的Object看成参数const x = (Sup) =&gt; &#123; return class extends Sup &#123; constructor()&#123; super(); console.log('C constructor'); &#125; &#125;;&#125;// 演化成下面的形式const C = Sup =&gt; class extends Sup &#123; constructor()&#123; super(); console.log('C constructor'); &#125;&#125;;//cls = new C(Object); // 不可以new，因为是一个普通函数，它的返回值是一个带constructor的类cls = C(A); // 调用它返回一个类，一个带constructor的classconsole.log(cls);c = new cls();console.log(c);// 其它写法c1 = new (C(Object))(); // new优先级太高了，所有后面要加括号才能先调用 可以改造上面序列化的例子了 123456789101112131415161718192021222324252627282930const Serialization = Sup =&gt; class extends Sup &#123; constructor(...args) &#123; console.log('Serialization constructor~~~'); super(...args); if (typeof(this.stringify) !== 'function')&#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point &#123; constructor(x,y)&#123; console.log('Point Constructor~~~~'); this.x = x; this.y = y; &#125;&#125;class Point3D extends Serialization(Point) &#123; constructor(x,y,z)&#123; super(x,y); // super是Serialization(Point)包装过的新类型 this.z = z; &#125; stringify () &#123; return `&lt;Point3D $&#123;this.x&#125;.$&#123;this.y&#125;.&gt;`; &#125;&#125;let p3d = new Point3D(70,80,90);console.log(p3d.stringify()); 注意：Serialization(Point)这一步实际上是一个匿名箭头函数调用，返回了一个新的类型，Point3D继承自这个新的匿名类型，增强了功能。React框架大量使用了这种Mixin技术。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务]]></title>
    <url>%2Fblog%2F2017%2F09%2F12%2FMySQL%20%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[事务TransactionInnoDB引擎，支持事务。 事务，由若干条语句组成的，指的是要做的一系列操作。 关系型数据库中支持事务，必须支持其四个属性（ACID）： 原子性，要求事务中的所有操作，不可分割，不能做了一部分操作，还剩一部分操作； 一致性，多个事务并行执行的结果，应该和事务排队执行的结果一致。如果事务的并行执行和多线程读写共享资源一样不可预期，就不能保证一致性。 隔离性，就是指多个事务访问共同的数据了，应该互不干扰。隔离性，指的是究竟在一个事务处理期间，其他事务能不能访问的问题。 持久性，比较好理解，就是事务提交后，数据不能丢失。 MySQL隔离级别MySQL隔离级别 隔离性不好，事务的操作就会互相影响，带来不同严重程度的后果。 首先看看隔离性不好，带来哪些问题： 更新丢失Lost Update 事务A和B，更新同一个数据，它们都读取了初始值100，A要减10，B要加100，A减去10后更新为90，B加100更新为200，A的更新丢失了，就像从来没有减过10一样。 脏读 事务A和B，事务B读取到了事务A未提交的数据（这个数据可能是一个中间值，也可能事务A后来回滚事务）。事务A是否最后提交并不关心。只要读取到了这个被修改的数据就是脏读。 不可重复读Unrepeatable read 事务A在事务执行中相同查询语句，得到了不同的结果，不能保证同一条查询语句重复读相同的结果就是不可以重复读。 例如，事务A查询了一次后，事务B修改了数据，事务A又查询了一次，发现数据不一致了。 注意，脏读讲的是可以读到相同的数据的，但是读取的是一个未提交的数据，不是提交的最终结果。 一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读 幻读Phantom read 事务A中同一个查询要进行多次，事务B插入数据，导致A返回不同的结果集，如同幻觉，就是幻读。 数据集有记录增加了，可以看做是增加了记录的不可重复读。 有了上述问题，数据库就必须要解决，提出了隔离级别。 隔离级别由低到高，如下表 隔离级别越高，串行化越高，数据库执行效率低；隔离级别越低，并行度越高，性能越高。 隔离级别越高，当前事务处理的中间结果对其它事务不可见程度越高。 SERIALIZABLE，串行了，解决所有问题 REPEATABLE READ，事务A中同一条查询语句返回同样的结果，就是可以重复读数据了。 例如语句为 ​ (select * from user) ​ 解决的办法有： ​ 1、对select的数据加锁，不允许其它事务删除、修改的操作 ​ 2、第一次select的时候，对最后一次确切提交的事务的结果做快照 解决了不可以重复读，但是有可能出现幻读。因为另一个事务可以增删数据。 READ COMMITTED，在事务中，每次select可以读取到别的事务刚提交成功的新的数据。因为读到的是提交后的数据，解决了脏读，但是不能解决 不可重复读 和 幻读 的问题。因为其他事务前后修改了数据或增删了数据。 READ UNCOMMITTED，能读取到别的事务还没有提交的数据，完全没有隔离性可言，出现了脏读，当前其他问题都可能出现。 事务语法​ START TRANSACTION 或 BEGIN 开始一个事务，START TRANSACTION是标准SQL的语法。 ​ 使用COMMIT提交事务后，变更成为永久变更。 ROLLBACK可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样（原子性）。 SET AUTOCOMMIT 语句可以禁用或启用默认的autocommit模式，用于当前连接。 SET AUTOCOMMIT = 0 禁用自动提交事务。 如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2Fblog%2F2017%2F08%2F21%2FMySQL%20%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库的正规化分析RDMBS设计范式基础概念设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同范式，各种范式呈递次规范，越高的范式数据库冗余越小 目前关系数据库有六种范式第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 满足最低要求的范式是第一范式（1NF）。 在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。 一般数据库只需满足第三范式(3NF）即可 范式1NF：无重复的列，每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。除去同类型的字段，就是无重复的列 说明：第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库 2NF：属性完全依赖于主键，第二范式必须先满足第一范式，要求表中的每个行必须可以被唯一的区分。通常为表加上一个列，以存储各个实例的唯一标识PK，非PK的字段需要与整个PK有直接相关性 复合主键 要求同时作用在多个主键上 3NF：属性不依赖于其它非主属性，满足第三范式必须先满足第二范式。第三范式要求一个数据库表中不包含已在其它表中已包含的非主关键字信息，非PK的字段间不能有从属关系. 表的优化与列类型选择表优化： 定长与变长分离 常用字段与不常用字段分离 在1对多需要关联统计的字段上添加冗余字段 列选择原则： 字段类型优先级 整形&gt; data , time &gt; enum,char &gt; varchar &gt; blob、text 够用就行、不要慷慨（如 smallint、varchar(N)） 尽量避免使用 NULL() 原因： null 不利于索引，要用特殊的字节来标注 hash冲突 拉链算法； 缺点：无法范围搜索、无法前缀索引 索引 ​ 提高查询速度 ​ 提高排序速度 ​ 提高分组速度 注意：innodb 来说 主键索引 既存储索引值又在叶子中存储行的数据 如果没有主键，则会Unicode做主键 如果没有unique则系统生成一个内部的rowid做主键 像innodb中，主键的索引结构中，既存储了主键值又存储了行数据，这种结构称为“聚簇索引” 聚簇索引 ​ 优势：根据主键查询条目比较时不用回行（数据就在主键节点下） ​ 劣势：如果碰到不规则数据插入时，造成频繁的页分裂。 索引优化策略： 独立地使用列： 尽量避免其参与运算，独立的列指索引列不能是表达式的一部分，也不能是函数的参数，在where条件中，始终将索引列单独放在比较符号的一侧 左前缀索引： 构建指定索引字段的左侧的字符数，要通过索引选择性来评估 索引选择性： 不重复的索引值和数据表的记录总数的比值 多列索引： AND操作时更适合使用多列索引，而非为每个列创建单独的索引 选择合适的索引列顺序：无排序和分组时，将选择性最高放左侧 只要列中含有NULL值，就最好不要在此例设置索引，复合索引如果有NULL值，此列在使用时也不会使用索引 尽量使用短索引，如果可以，应该制定一个前缀长度 对于经常在where子句使用的列，最好设置索引 对于有多个列where或者order by子句，应该建立复合索引 对于like语句，以%或者‘-’开头的不会使用索引，以%结尾会使用索引 尽量不要在列上进行运算（函数操作和表达式操作） 尽量不要使用not in和&lt;&gt;操作 SQL语句性能优化 查询时，能不要就不用，尽量写全字段名 大部分情况连接效率远大于子查询 多表连接时，尽量小表驱动大表，即小表 join 大表 在有大量记录的表分页时使用limit 对于经常使用的查询，可以开启缓存 多使用explain和profile分析查询语句 查看慢查询日志，找出执行时间长的sql语句优化 参考: 58到家数据库30条军规解读 http://zhuanlan.51cto.com/art/201702/531364.htm]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-反射]]></title>
    <url>%2Fblog%2F2017%2F06%2F19%2FPython-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述 运行时，区别于编译时，指的是程序被加载到内存中执行的时候。反射，reflection，指的是运行时获取类型定义信息。一个对象能够在运行时，像照镜子一样，反射出其类型信息。简单说，在Python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或者自省。具有反射能力的函数有：type()、isinstance()、callable()、dir()、getattr() 反射相关的函数和方法 这种动态增删属性的方式是运行时改变类或者实例的方式，但是装饰器或Mixin都是定义时就决定了，因此反射能力具有更大的灵活性。 反射相关的魔术方法__getattr__()一个类的属性会按照继承关系找，如果找不到，就会执行 getattr() 方法，如果没有这个方法，就会抛出AttributeError异常表示找不到属性。查找属性顺序为：instance.dict –&gt; instance.class.dict –&gt; 继承的祖先类（直到object）的dict —找不到–&gt; 调用getattr() __setattr__()__setattr__() 方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例的dict 。 __delattr__()可以阻止通过实例删除属性的操作。但是通过类依然可以删除属性。 __getattribute__()实例的所有的属性访问，第一个都会调用 getattribute 方法，它阻止了属性的查找，该方法应该返回（计算 后的）值或者抛出一个AttributeError异常。它的return值将作为属性查找的结果。如果抛出AttributeError异常，则会直接调用 getattr 方法，因为表示属性没有找到。 __getattribute__ 方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法以访问需要的任何属性，例如 object.getattribute(self, name) 。注意，除非你明确地知道 getattribute 方法用来做什么，否则不要使用它。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>魔术方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript_Mixin]]></title>
    <url>%2Fblog%2F2017%2F06%2F18%2FJavaScript-Mixin%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Mixin模式，混合模式。这是一种不用继承就可以复用的技术。主要还是为了解决多重继承的问题。多继承的继承路径是个问题。JS是基于对象的，类和对象都是对象模板。 混合mixin，指的是将一个对象的全部或者部分拷贝到另一个对象上去。其实就是属性了。可以将多个类或对象混合成一个类或对象。 继承实现先看一个继承实现的例子 12345678910111213141516171819202122232425class Serialization &#123; constructor() &#123; console.log("Serialization construtor ~~~~~~") if (typeof(this.stringfy) !== "function") &#123; throw new ReferenceError("should define stringify."); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log("Point Constructor"); super(); // 调用父构造器 this.x = x; this.y = y; &#125; stringfy() &#123; return `&lt;Point x="$&#123;this.x&#125;, y=$&#123;this.y&#125;"&gt;`; &#125;&#125;s = new Serialization(); // 构造Serialization失败p = new Point(4,5); // 构造子类对象时，调用父类构造器执行也会失败 父类构造函数中，要求具有属性是stringify的序列化函数，如果没有则抛出异常。 以下是完整继承的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Serialization &#123; constructor() &#123; console.log("Serialization construtor ~~~~~~") if (typeof(this.stringfy) !== "function") &#123; throw new ReferenceError("should define stringify."); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log("Point Constructor"); super(); // 调用父构造器 this.x = x; this.y = y; &#125; stringfy() &#123; return `&lt;Point x="$&#123;this.x&#125;, y=$&#123;this.y&#125;"&gt;`; &#125;&#125;class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); // 调用父构造器 this.z = z; &#125; stringfy() &#123; return `&lt;Point3D x="$&#123;this.x&#125;, y=$&#123;this.y&#125;, z=$&#123;this.z&#125;"&gt;` &#125;&#125;p = new Point(4, 5);console.log(p.stringfy());console.log("=====================");p3d = new Point3D(7, 8, 9);console.log(p3d.stringfy());/* 输出结果Point ConstructorSerialization construtor ~~~~~~&lt;Point x="4, y=5"&gt;=====================Point ConstructorSerialization construtor ~~~~~~&lt;Point3D x="7, y=8, z=9"&gt;*/ 高阶对象实现将类的继承构建成箭头函数。 12345678910111213141516171819202122232425262728293031323334353637const Serialization = Sup =&gt; class extends Sup&#123; constructor(...args)&#123; console.log("Serialization constructor"); super(...args); if (typeof this.stringfy !== "function")&#123; throw ReferenceError("Stringfy is not define."); &#125; &#125;&#125;;class Point&#123; constructor(x, y)&#123; console.log("Point sonctructor"); this.x = x; this.y = y; &#125;&#125;class Point3D extends Serialization(Point)&#123; constructor(x, y, z)&#123; super(x, y); this.z = z; &#125; stringfy()&#123; console.log(`&lt;Point $&#123;this.x&#125;.$&#123;this.y&#125;.$&#123;this.z&#125;&gt;`) &#125;&#125;let p3d = new Point3D(3, 4, 5);p3d.stringfy();/* 输出结果Serialization constructorPoint sonctructor&lt;Point 3.4.5&gt;*/]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Mixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-高阶函数]]></title>
    <url>%2Fblog%2F2017%2F06%2F07%2Fpython-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[高阶函数定义 函数可以作为普通变量、参数、返回值等等 数学概念 y = g( f( x ) ) 在数学和计算机科学中，高阶函数应当是最少满足下面一个条件的函数 接受一个或多个函数作为参数 输出一个函数 自定义sort函数 123456789101112def sort(iterable, reverse=False, key=lambda x,y: x&lt;y): ret = [] for x in iterable: for i,y in enumerate(ret): flag = key(x,y) if not reverse else not key(x,y) if flag: ret.insert(i,x) break else: ret.append(x) return retprint(sort([4,7,2,9,1,6])) 内建函数-高阶函数 filter(function, iterable) 过滤可迭代对象的元素，返回一个迭代器 function 一个具有一个参数的函数，返回bool 例如：过滤出数列中被3整除的数字 list( filter( lambda x: x%3==0, [1,9,45,36,-3,86,47,96] ) ) map(function, 对多个可迭代对象的元素按照指定的函数进行映射，返回一个迭代器 list( map( lambda x: 2*x+1, range(5) ) ) dict( map( lambda x: (x%5,x), range(500) ) ) list( map( lambda x,y: x+y, [1,2,3,4,5], [2,3,4,5,6] ) ) 柯里化Currying 柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。 z = f(x, y) 转换成 z = f(x)(y) 12345678910# 将加法函数柯里化def add(x,y): return x + y# 转换如下def add(x): def _add(y): return x + y return _addadd(5)(6) 函数注解 Function Annotaions 对函数的参数、返回值进行类型注解 只对函数参数做一个辅助的说明，并不对函数的参数进行类型检查 函数注解的信息，保存在annotaions 属性中 python3.6 引入 i:int = 3 12add.__annotations__&#123;&apos;x&apos;: &lt;class &apos;int&apos;&gt;, &apos;y&apos;: &lt;class &apos;str&apos;&gt;, &apos;return&apos;: &lt;class &apos;str&apos;&gt;&#125; 函数参数的检查，一定是在函数外 函数应该作为参数，传入到检查函数中 检查函数拿到函数传入的实际参数，与形参声明对比 annotaions 属性是一个字典，其中包括返回值类型的声明，假设要做位置参数的判断，无法和字典中的声明对比。使用inspect模块 inspet模块 -&gt; 提供获取对象信息的函数，可以检查函数和类、类型检查 inspect(callable) 获取签名（函数签名包含了一个函数的信息，包含函数名、它的参数类型、它所在的类和名称空间及其他信息） 123456789101112131415161718192021222324252627282930313233343536import inspectdef add(x:int, y:int, *args, **kwargs) -&gt; int: return x + ysig = inspect.signature(add)print(sig, type(sig)) &gt;&gt;&gt; 函数签名 (x:int, y:int, *args, **kwargs) -&gt; int &lt;class 'inspect.Signature'&gt;print('params:',sig.parameters) &gt;&gt;&gt; params: OrderedDict([('x', &lt;Parameter "x:int"&gt;), ('y', &lt;Parameter "y:int"&gt;), ('args', &lt;Parameter "*args"&gt;), ('kwargs', &lt;Parameter "**kwargs"&gt;)])print('return:',sig.return_annotation ) &gt;&gt;&gt; return: &lt;class 'int'&gt;print(sig.parameters['x'],type(sig.parameters['x'])) &gt;&gt;&gt; x:int &lt;class 'inspect.Parameter'&gt;print(sig.parameters['y'].annotation) &gt;&gt;&gt; &lt;class 'int'&gt;print(sig.parameters['args'],type(sig.parameters['args'])) &gt;&gt;&gt; *args &lt;class 'inspect.Parameter'&gt; print(sig.parameters['args'].annotation) &gt;&gt;&gt; &lt;class 'inspect._empty'&gt;print(add.__annotations__) &gt;&gt;&gt; &#123;'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'str'&gt;&#125;print(sig.parameters['kwargs']) &gt;&gt;&gt; **kwargsprint(sig.parameters['kwargs'].annotation) &gt;&gt;&gt; &lt;class 'inspect._empty'&gt; inspect.isfunction(add) # 是否是函数 inspect.ismethod(add) # 是否是类的方法 inspect.isgenerator(add) # 是否是生成器对象 inspect.isgeneratorfunction(add) # 是否是生成器函数 inspect.isclass(add) # 是否是类 inspect.ismodule(add) # 是否是模块 inspect.isbuiltin(add) # 是否是内建对象 Parameter 对象 保存在元组中，是只读的 name，参数的名字 annotation ，参数的注解，可能没有定义 default，参数的缺省值，可能没有定义 empty，特殊的类，用来标记default属性或者注释annotation属性的空值 kind，实参如何绑定到形参，就是形参的类型 POSITIONAL_ONLY ，值必须是位置参数提供 (Python中没有) POSITIONAL_OR_KEYWORD ， 值可以作为关键字或者位置参数提供 VAR_POSITIONAL ， 可变参数，对应*args KEYWORD_ONLY ，kwword_only 参数，对应*或者args之后的出现的非可变参数关键字参数 VAR_KEYWORD ，可变关键字参数，对应**kwargs12345678910111213141516171819202122232425262728293031### 检查用户输入是否符合参数注解的要求from functools import wrapsimport inspectdef check(fn): @wraps(fn) def wrapper(*args,**kwargs): sig = inspect.signature(fn) params = sig.parameters # 有序字典 # print(params) values = list(params.values()) # flag = True for i,p in enumerate(args): param = values[i] if param.annotation is not param.empty and not isinstance(p,param.annotation): print(p,&apos;!==&apos;,values[i].annotation) # flag = False # break # if not flag: # raise TypeError(&apos;都是你的错&apos;) for k,v in kwargs.items(): if params[k].annotation is not inspect._empty and isinstance(v,params[k].annotation): print(k,v,&apos;!==&apos;,params[k].annotation) return fn(*args,**kwargs) return wrapper@checkdef add(x:int,y:int=6)-&gt;int: return x + yadd(20,30)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 笔记]]></title>
    <url>%2Fblog%2F2017%2F05%2F29%2FRedis%20%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开源的（BSD协议），使用ANSI C 编写，基于内存的且支持持久化，高性能的Key-Value的NoSQL数据库。支持数据结构类型丰富，有如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。丰富的支持主流语言的客户端，C、C++、Python、Erlang、R、C#、Java、PHP、Objective-C、Perl、Ruby、Scala、Go、JavaScript。 用途：缓存（StackOverFlow）、数据库（微博）、消息中间件（微博） 安装Linux单节点安装123456789101112131415161718192021# yum -y install gcc tcl# tar xf redis-3.2.12.tar.gz# mv redis-3.2.12/ redis# cd redis# make如果出错，需要redis目录下# cd deps# make jemalloc# make lua# make linenoise# make hiredis# cd ..缺省安装# make install默认安装到/usr/local/bin自定义安装# mkdir -p /mds/redis# make PREFIX=/mds/redis install 可执行文件redis-benchmarkredis-check-aofredis-check-dumpredis-cliredis-server环境变量可以将下面的变量追加入到~/.bash_profile文件末尾 12export REDIS_HOME=/mds/redisexport PATH=$PATH:$REDIS_HOME/bin redis服务 123456789101112131415可以查看redis-server启动的各种命令参考帮助# redis-server --helpredis-3.2.12.tar.gz中的utils目录# ./install_server.sh完成后，配置文件在/etc/redis/6379.conf可以把redis做成服务# mv /etc/init.d/redis_6379 /etc/init.d/redisd# chkconfig redisd on查看后修改配置文件后，可以启动redis服务# service redisd start# service redisd start|stop|restart|status# ss -tanl 使用install_server.sh脚本生成的redis配置文件为/etc/redis/6379.conf 1234567891011121314151617181920212223242526272829303132333435# 3.x增加了bind，不设置在本地所有网络接口监听#bind 127.0.0.1bind 192.168.142.135 127.0.0.1# 3.x增加了保护模式，默认开启# 开启保护模式时，如果不使用bind绑定IP地址，或不使用密码，那么只能本地地址访问或使用Unix socket文件protected-mode yes# 后台服务daemonize yesport 6379# 缺省DB是0，设置DB的数目databases 16# 2种持久化方式# RDB: Redis DB 默认开启# 下面是执行快照的条件# In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changedsave 900 1save 300 10save 60 10000dbfilename dump.rdb# AOF 默认关闭appendonly noappendfilename "appendonly.aof"appendfsync everysec说明：用于测试，或者内存小可以设置最大内存，但是生产环境一定尽量使用内存maxmemory &lt;bytes&gt; Redis数据模型redis支持数据模型非常丰富 键KeyRedis key 值是二进制安全的，这意味着可以用任何二进制序列作为key值，从形如”foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效key值 Key取值原则键值不需要太长，消耗内存，而且查找这类键值的计算成本较高键值不宜过短，可读性较差习惯上key采用’user:123:password’形式，表示用户id为123的用户的密码 字符串字符串是一种最基本简单的Redis值类型。Redis字符串是二进制安全的，这意味着一个Redis字符串能包含任意类型的数据，例如： 一张JPEG格式的图片或者一个序列化的Ruby对象。一个字符串类型的值最多能存储512M字节的内容。 python中redis编程安装redis库$ pip install redis 123456789101112import redisdb = redis.Redis('192.168.142.135') # 默认本地6379的0号库print(db.keys('*')) # 查看所有匹配keysdb.set('testbin', 0b01100010) # 0x62print(db.get('testbin'))db.set(0b11, 0x63)print(db.get(0b11))print(db.get(3))print(db.get('3'))print(db.keys('*')) # 查看所有匹配keys 注意：上例中0x62实际上发生了类型变化，因为返回的bytes类型98，实际上对应ASCII的98，已经是2字节了。数值会先转换成10进制64位有符号数后，再转成字符串，存入redis中。 查看帮助1234&gt; Help 查看帮助&gt; Help &lt;tab&gt; 使用tab键切换帮助&gt; Help set 查看set命令帮助&gt; Help @string 查看命令组帮助 字符串设置SET key value [EX seconds][PX milliseconds] [NX|XX]设置字符串值EX 设置过期时间，秒，等同于 SETEX key seconds valuePX 设置过期时间，毫秒，等同于 PSETEX key milliseconds valueNX 键不存在，才能设置，等同于 SETNX key valueXX 键存在时，才能设置MSET key value [key value ...]设置多个键的字符串值，key存在则覆盖，key不存在则增加原子操作MSETNX key value [key value ...]key不存在则设置，key存在则失败。nx指不存在。这个命令是原子操作 过期操作和生存时间Redis中可以给每个Key设置一个生存时间（秒或毫秒），当达到这个时长后，这些键值将会被自动删除EXPIRE key secondsPEXPIRE key milliseconds设置多少秒或者毫秒后过期EXPIREAT key timestampPEXPIREAT key milliseconds-timestamp设置在指定Unix时间戳过期PERSIST key持久key，即取消过期 适用场景一、多少秒过期，例如一个缓存数据失效二、PEXPIREAT key milliseconds-timestamp，比如现在开始缓存数据，到0点失效Time To Live，Key的剩余生存时间 TTL keyPTTL keykey存在但没有设置TTL，返回-1key存在，但还在生存期内，返回剩余的秒或者毫秒key曾经存在，但已经消亡，返回-2（2.8版本之前返回-1） key操作keys patternpattern可以取如下值： 任意长度字符 ? 任意一个字符 [] 字符集合，表示一个字符 TYPE key key类型EXISTS key key是否存在RENAME key newkey 、 RENAMENX key newkey键重命名DEL key [key ...]键删除 字符串获取GET key 获取值MGET key [key ...]获取多个给定的键的值GETSET key value返回旧值并设置新值，如果键不存在，就创建并赋值STRLEN key 字符串长度 字符串操作APPEND key value追加字符串。如果键存在就追加；如果不存在就等同于SET key value获取子字符串GETRANGE key start end 索引值从0开始，支持负索引，-1表示最后一个字符。范围是[start, end]，start必须在end的左边，否则返回空串SETRANGE key offset value 从指定索引处开始覆盖字符串，返回覆盖后字符串长度。key不存在会创建新的 自增、自减INCR key 和 DECR key 步长1的增减INCRBY key decrement和 DECRBY key decrement步长增减字符串值会被解释成64位有符号的十进制整数来操作，结果依然转成字符串 库操作redis-cli --helpredis-cli -n 2登录不同的库FLUSHDB清除当前库数据FLUSHALL清除所有库中的数据 位图bitmap位图不是真正的数据类型，它是定义在字符串类型上，只不过把字符串按位操作一个字符串类型的值最多能存储512M字节的内容，可以表示2 32 位位上限：512=2 91M=1024*1024=2 10+101Byte=8bit=2 3 bit2 (9+10+10+3) = 2 32 b = 4294967296 b ，接近43亿个位 SETBIT key offset value设置某一位上的值offset偏移量，从0开始value不写，默认是0 GETBIT key offset获取某一位上的值BITPOS key bit [start][end]返回指定值0或者1在指定区间上第一次出现的位置 BITCOUNT key [start][end]统计指定位区间上值为1的个数从左向右从0开始，从右向左从-1开始，注意官方start、end是位，测试后是字节BITCOUNT testkey 0 0表示从索引为0个字节到索引为0个字节，就是第一个字节的统计BITCOUNT testkey 0 -1等同于 BITCOUNT testkey最常用的就是 BITCOUNT testkey 位操作对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上operation 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种BITOP AND destkey key [key ...]，对一个或多个 key 求逻辑并，并将结果保存到 destkeyBITOP OR destkey key [key ...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkeyBITOP XOR destkey key [key ...]，对一个或多个 key 求逻辑异或，并将结果保存到 destkeyBITOP NOT destkey key ，对给定 key 求逻辑非，并将结果保存到 destkey除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0空的 key 也被看作是包含 0 的字符串序列 List列表 其列表是基于双向链表实现，列表头尾增删快，中间增删慢 元素是字符串类型 元素可以重复出现 索引支持正索引和负索引，从左至右从0开始，从右至左从-1开始 命令说明 字母 说明 B Block阻塞 L Left 左起 R Right 右起 X exist 存在 `LLEN key 返回列表元素个数 LPUSH key value [value ...] 从左边向队列中压入元素LPUSHX key value 从左边向队列加入元素，要求key必须存在RPUSH key value [value ...]从右边向队列中压入数据RPUSHX key value 要求key存在 LPOP key从左边弹出列表中一个元素RPOP key从右边弹出列表中一个元素 RPOPLPUSH source destination 从源列表中右边pop一个元素，从左边加入到目标列表LRANGE key start stop 返回列表中指定访问的元素，例如LRANGE user 0 -1 LINDEX key index 返回列表中指定索引的元素LSET key index value 设置列表中指定索引位置的元素值，index不能超界 LREM key count value 从左边删除列表中与value相等的元素count &gt; 0 从左至右搜索，移除与 value 相等的元素，数量至多为 count 次count &lt; 0 从右至左搜索，移除与 value 相等的元素，数量至多为 -count次count = 0移除列表中所有value值 LTRIM key start stop 去除指定范围外的元素RPUSH listkey c abc c ab 123 ab bj ab redis listLTRIM listkey 0 -1 # 什么都没有去除LTRIM listkey 1 -1# 去掉左边头LTRIM listkey 1 10000 LINSERT key BEFORE|AFTER pivot value 在列表中某个存在的值（pivot）前或后插入元素一次，key或pivot不存在，不进行任何操作RPUSH lst 1 2 3 4 2 8LINSERT lst AFTER 2 PythonLINSERT lst BEFORE 2 Ruby 阻塞如果弹出的列表不存在或者为空，就会阻塞超时时间设置为0，就是永久阻塞，直到有数据可以弹出如果多个客户端阻塞在同一个列表上，使用First In First Service原则，先到先服务 BLPOP key [key ...] timeout 列表左边阻塞弹出元素。timeout是超时秒数，为0为永久阻塞。BRPOP key [key ...] timeout列表左边阻塞弹出元素BRPOPLPUSH source destination timeout 从一个列表尾部阻塞弹出元素压入到另一个列表的头部 hash散列值是由field和value组成的map键值对field和value都是字符串类型 HSET key field value设置单个字段。field不存在创建，存在覆盖valueHSETNX key field value 设置单个字段，要求field不存在。如果key不存在，相当于field也不存在HMSET key field value [field value ...] 设置多个字段HLEN key 返回字段个数HEXISTS key field 判断字段是否存在。key或者field不存在，返回0 HGET key field 返回字段值HMGET key field [field ...] 返回多个字段值HGETALL key 返回所有的键值对HKEYS key返回所有字段名HVALS key 返回所有值HINCRBY key field increment在字段对应的值上进行整数的增量计算HINCRBYFLOAT key field increment 在字段对应的值上进行浮点数的增量计算HDEL key field [field ...] 删除指定的字段 hash用途节约内存空间每创建一个键，它都会为这个键储存一些附加的管理信息（比如这个键的类型，这个键最后一次被访问的时间等等）所以数据库里面的键越多，redis数据库服务器在储存附加管理信息方面耗费的内存就越多，花在管理数据库键上的CPU时间也会越多 不适合hash的情况使用二进制位操作命令：因为Redis目前支持对字符串键进行SETBIT、GETBIT、BITOP等操作，如果你想使用这些操作，那么只能使用字符串键，虽然散列也能保存二进制数据使用过期键功能：Redis的键过期功能目前只能对键进行过期操作，而不能对散列的字段进行过期操作，因此如果你要对键值对数据使用过期功能的话，那么只能把键值对储存在字符串里面 Set集合集合的元素是无序的、去重的，元素是字符串类型。SADD key member [member ...]增加一个或多个元素，元素已存在将忽略SREM key member [member ...] 移除一个或多个元素，元素不存在自动忽略SCARD key返回集合中元素的个数。不需要遍历。SMEMBERS key 返回集合中的所有元素。注意，如果集合中元素过多，应当避免使用该方法SISMEMBER key member元素是否是在集合中 SRANDMEMBER key [count]随机返回集合中指定个数的元素如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值如果 count 为 0，返回空如果 count 不指定，随机返回一个元素 SPOP key 从集合中随机移除一个元素并返回该元素SMOVE source destination member 把元素从源集合移动到目标集合集合运算 差集SDIFF key [key ...]从第一个key的集合中去除其他集合和自己的交集部分SDIFFSTORE destination key [key ...]将差集结果存储在目标key中 交集SINTER key [key ...]取所有集合交集部分SINTERSTORE destination key [key ...] 将交集结果存储在目标key中 并集SUNION key [key ...] 取所有集合并集SUNIONSTORE destination key [key ...]将并集结果存储在目标key中 SortedSet有序集合类似Set集合，有序的集合。每一个元素都关联着一个浮点数分值（Score），并按照分值从小到大的顺序排列集合中的元素。分值可以相同 ZADD key score member [score member ...]增加一个或多个元素。如果元素已经存在，则使用新的score ZCARD key 返回集合的元素个数 ZCOUNT key min max 返回指定score范围元素的个数 ZSCORE key member 显示分值 ZINCRBY key increment member增加或减少分值。increment为负数就是减少 ZRANGE key start stop [WITHSCORES]返回指定索引区间元素如果score相同，则按照字典序lexicographical order 排列默认按照score从小到大，如果需要score从大到小排列，使用ZREVRANGEZREVRANGE key start stop [WITHSCORES] 返回指定索引区间元素如果score相同，则按照字典序lexicographical order 的 逆序 排列默认按照score从大到小，如果需要score从小到大排列，使用ZRANGE ZRANK key member 返回元素的排名（索引）ZREVRANK key member 返回元素的逆序排名（索引） ZRANGEBYSCORE key min max [WITHSCORES][LIMIT offset count] 返回指定分数区间的元素返回score默认属于[min,max]之间，元素按照score升序排列，score相同字典序LIMIT中offset代表跳过多少个元素，count是返回几个。类似于Mysql使用小括号，修改区间为开区间，例如 (5 或者 (10、5)-inf和+inf表示负无穷和正无穷 ZREVRANGEBYSCORE key max min [WITHSCORES][LIMIT offset count]降序返回指定分数区间的元素返回score默认属于[min,max]之间，元素按照score降序排列，score相同字典降序 ZREM key member [member ...]移除一个或多个元素。元素不存在，自动忽略ZREMRANGEBYRANK key start stop 移除指定排名范围的元素ZREMRANGEBYSCORE key min max移除指定分值范围的元素 集合运算并集ZUNIONSTORE destination numkeys key [key ...][WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]numkeys指定key的数量，必须WEIGHTS选项，与前面设定的key对应，对应key中每一个score都要乘以这个权重AGGREGATE选项，指定并集结果的聚合方式SUM：将所有集合中某一个元素的score值之和作为结果集中该成员的score值，默认MIN：将所有集合中某一个元素的score值中最小值作为结果集中该成员的score值MAX：将所有集合中某一个元素的score值中最大值作为结果集中该成员的score值 交集ZINTERSTORE destination numkeys key [key ...][WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]numkeys指定key的数量，必须WEIGHTS选项，与前面设定的key对应，对应key中每一个score都要乘以这个权重AGGREGATE选项，指定并集结果的聚合方式SUM：将所有集合中某一个元素的score值之和作为结果集中该成员的score值MIN：将所有集合中某一个元素的score值中最小值作为结果集中该成员的score值MAX：将所有集合中某一个元素的score值中最大值作为结果集中该成员的score值 Redis持久化持久化：将数据从掉电易失的内存存放到能够永久存储的设备上Redis服务是使用内存来存储数据，如果掉电、服务崩溃都会导致Redis中数据丢失，如有必要，可以持久化数据。 Redis持久化方式：RDB（Redis DB）、AOF（AppendOnlyFile） RDB在默认情况下，Redis 将某时间点的数据库快照保存在名字为 dump.rdb的二进制文件中 策略 自动：按照配置文件中的条件满足就执行BGSAVE 手动：客户端发起SAVE、BGSAVE命令 配置12345save 900 1save 300 10save 60 10000dbfilename dump.rdbdir /var/lib/redis/6379 save 60 1000，Redis要满足在60秒内至少有1000个键被改动，会自动保存一次只要满足上面3个条件之一，就自动执行快照执行完后，时间计数器和次数计数器都会归零重新计数。这多个条件不是叠加效果 SAVE命令：阻塞式命令，执行期间不响应客户端的请求BGSAVE：非阻塞命令，执行期间还可以接收并处理客户端请求，会folk一个子进程创建RDB文件 12192.168.142.135:6379&gt; SAVE192.168.142.135:6379&gt; BGSAVE 优点 完全备份，不同时间的数据集备份可以做到多版本恢复 紧凑的单一文件，方便网络传输，适合灾难恢复 快照文件直接恢复，大数据集速度较AOF快 缺点 会丢失最近写入、修改的而未能持久化的数据 folk过程非常耗时，会造成毫秒级不能响应客户端请求 RDB备份策略​ 创建一个定时任务cron job，每小时或者每天将dump.rdb复制到指定目录​ 确保备份文件名称带有日期时间信息，便于管理和还原对应的时间点的快照版本​ 定时任务删除过期的备份​ 如果有必要，跨物理主机、跨机架、异地备份 AOFAppend only file，采用追加的方式保存，默认文件appendonly.aof 。记录所有的写操作命令，在服务启动的时候使用这些命令就可以还原数据库 AOF写入机制AOF方式不能保证绝对不丢失数据目前常见的操作系统中，执行系统调用write函数，将一些内容写入到某个文件里面时，为了提高效率，系统通常不会直接将内容写入硬盘里面，而是先将内容放入一个内存缓冲区（buffer）里面，等到缓冲区被填满，或者用户执行fsync调用和fdatasync调用时才将储存在缓冲区里的内容真正的写入到硬盘里，未写入磁盘之前，数据可能会丢失 写入磁盘的策略appendfsync选项，这个选项的值可以是always、everysec或者no Always：服务器每写入一个命令，就调用一次fdatasync，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，也不会丢失任何已经成功执行的命令数据 Everysec（默认）：服务器每一秒重调用一次fdatasync，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，最多只丢失一秒钟内的执行的命令数据 No：服务器不主动调用fdatasync，由操作系统决定何时将缓冲区里面的命令写入到硬盘。这种模式下，服务器遭遇意外停机时，丢失命令的数量是不确定的 运行速度：always的速度慢，everysec和no都很快 AOF重写机制写操作越来越多的被记录，AOF文件会很大。Redis会合并写操作，以压缩AOF文件。合并重复的写操作，AOF会使用尽可能少的命令来记录。 重写过程 folk一个子进程负责重写AOF文件 子进程会创建一个临时文件写入AOF信息 父进程会开辟一个内存缓冲区接收新的写命令 子进程重写完成后，父进程会获得一个信号，将父进程接收到的新的写操作由子进程写入到临时文件中 新文件替代旧文件 注：如果写入操作的时候出现故障导致命令写半截，可以使用redis-check-aof工具修复 AOF重写触发手动：客户端向服务器发送BGREWRITEAOF命令自动：配置文件中的选项，自动执行BGREWRITEAOF命令auto-aof-rewrite-min-size &lt;size&gt;，触发AOF重写所需的最小体积：只要在AOF文件的体积大于等于size时，才会考虑是否需要进行AOF重写，这个选项用于避免对体积过小的AOF文件进行重写auto-aof-rewrite-percentage &lt;percent&gt;，指定触发重写所需的AOF文件体积百分比：当AOF文件的体积大于auto-aof-rewrite-min-size指定的体积，并且超过上一次重写之后的AOF文件体积的percent %时，就会触发AOF重写。（如果服务器刚刚启动不久，还没有进行过AOF重写，那么使用服务器启动时载入的AOF文件的体积来作为基准值）。将这个值设置为0表示关闭自动AOF重写 重写配置举例 1234567auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb当AOF文件大于64MB时候，可以考虑重写AOF文件只有当AOF文件的增量大于起始size的100%时（就是文件大小翻了一倍），启动重写appendonly yes默认关闭，请开启 优点 写入机制，默认fysnc每秒执行，性能很好不阻塞服务，最多丢失一秒的数据 重写机制，可以优化AOF文件体积 如果误操作了（FLUSHALL等），只要AOF未被重写，停止服务移除AOF文件尾部FLUSHALL命令，重启Redis，可以将数据集恢复到 FLUSHALL 执行之前的状态 缺点 相同数据集，AOF文件体积较RDB大了很多 恢复数据库速度叫RDB慢（文本，命令重演）]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-列表解析式-生成器表达式]]></title>
    <url>%2Fblog%2F2017%2F05%2F24%2FPython-%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[函数 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元 完成一定的功能 函数名就是标识符，命名要求一样 Python的函数没有return语句，隐示会返回一个None值 定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常 函数是可调用的对象，callable() 参数位置参数12- def func(x, y, z) 调用使用func(1,3,5)- 按照参数定义顺序传入实参 关键字参数12- def func(x, y, z) 调用时使用func(x=1, y=2, z=3)- 使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可以和定义顺序不同 传参1- 要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的 参数默认值（缺省值）1234- 定义时，在形参后跟上一个值- 作用 - 参数的默认值可以在为传入足够的实参的时候，对没有给定的参数赋值为默认值 - 参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用 位置可变参数12- 在形参前使用*表示形参是可变参数，可以接受多个实参- 收集多个实参为一个tuple 关键字可变参数 12- 形参前使用**符号，表示可以接受多个关键字参数- 收集的实参名称和值组成一个字典 keyword-only 参数（python3加入）如果在一个星号参数后，或者一个位置可变参数后，出现的普通参数，实际上已经不是普通参数了，而是keyword-only参数 keyword-only 参数另一种形式12345def func(*, x, y): print(x, y) func(x=5, y=7)* 号之后，普通参数都变成了必须给出的keyword-only参数 ####可变参数总结12345- 有位置可变参数和关键字可变参数- 位置可变参数在形参前使用一个星号*- 关键字可变参数在形参前使用两个星号**- 位置可变参数和关键字参数都可以收集若干个实参，位置可变 参数收集形成一个tuple，关键字可变参数收集成形成一个dict- 混合使用参数的时候，可变参数要放到参数列表的最后，普通参数需要放到参数列表前面，位置可变参数需要在关键字可变参数之前 参数规则1- 参数列表顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值），可变关键字参数 参数解构12345- 给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参- 非字典类型使用*解构成位置参数- 字典类型使用**解构成关键字参数- 提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配- 给参数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参 函数的返回值1234567 - 函数不能同时返回多个值 - return [1,3,5] 是指明返回一个列表，是一个列表对象 - return 1,3,5 看似返回多个值，隐式的被Python封装成了一个元组def showlist(): return 1,3,5x,y,z = showlist() # 使用解构提取更为方便 函数嵌套1234567891011 - 在一个函数中定义了另外一个函数 def outer(): def inner(): print(&apos;inner&apos;) print(&apos;outer&apos;) inner() - 函数有可见范围，这就是作用域的概念- 内部函数不能在外部直接使用，会抛NameError异常，因为它不可见 作用域*123456789101112131415161718192021222324 - 一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域 - 全局作用域 - 在整个程序运行环境中都可见 - 局部作用域 - 在函数、类等内部可见 - 局部变量使用范围不能超过其所在的局部作用域def outer(): o = 65 def inner(): o = 97 print(&apos;inner &#123;&#125;&apos;.format(o)) print(chr(o)) print(&quot;outer &#123;&#125;&quot;.format(o)) print(chr(o)) inner() print(chr(o)) &gt;&gt;&gt;: outer()outer 65Ainner 97aA 从嵌套结构例子看出12- 外层变量作用域在内层作用域可见- 内层作用域inner中，如果定义了一个和外层做作用域中重名的变量，这个变量并没有覆盖外层作用域中的o 123456789101112131415161718&gt;&gt;&gt;: x = 5&gt;&gt;&gt;: def foo():&gt;&gt;&gt;: x += 1&gt;&gt;&gt;: foo() # 报错-------------------------------------------------------UnboundLocalError Traceback (most recent call last)&lt;ipython-input-77-c19b6d9633cf&gt; in &lt;module&gt;()----&gt; 1 foo()&lt;ipython-input-76-06a3a4e92a76&gt; in foo() 1 def foo():----&gt; 2 x += 1 3UnboundLocalError: local variable &apos;x&apos; referenced before assignment&gt;&gt;&gt;: x = 5 上面代码报错原因 x += 1 其实是 x = x + 1 相当于在foo函数内部定义一个局部变量x ，那么foo内部所有x 都是这个局部变量x 了 但是这个x还没有完成复制，就被右边拿来做加1 操作了 全局变量global12345 - 使用global关键字的变量，将函数内的变量声明为使用外部的全局作用域中 - x += 1 这种特殊形式产生的错误的原因？先引用后赋值。而python动态语言是赋值才算定义，才能被引用。 - 解决办法：在这条语句前增加x=0 之类的赋值语句，或者使用global告诉哦内部作用域，去全局作用域查找变量定义- - 内部作用域使用x=5之类的赋值语句会重新定义局部作用域使用的变量x， 但是，一旦这个作用域中使用global声明x为全局的，那么x=5 相当于在为全局作用域的变量x赋值。 global 使用原则123- 外部作用域变量会在内部作用域可见，但也不要在这个内部作用域中直接使用，因为函数的目的是为了封装，尽量与外界隔离- 如果函数需要使用外部全局变量，请使用函数的形参传参解决- 一句话：不用global。学习他就是为了深入理解变量作用域 闭包12- 自由变量：未在本地作用域中定义的变量。例如定义在内存函数外的外层函数的作用域中的变量- 闭包：就是一个概念，出现在嵌套函数中，指的是内层函数引用了外层函数的自由变量，就形成了闭包。很多语言都有这个概念。最熟悉就是JavaScript。 Python2 中实现闭包方式 12345678910111213def counter(): c = [0] def inc(): c[0] += 1 return c[0] return incfoo = counter()print(foo(),foo())&gt;&gt;&gt;: 1 2c = 100print(foo())&gt;&gt;&gt;: 3 nonlocal 关键字1- 使用了nonlocal关键字，将变量标记为不在本地作用域定义，而在上级的某一级局部作用域中定义，但不能是全局作用域中定义 默认值得作用域 123456def foo(xyz=[]): xyz.append(1) print(xyz)foo() #[1]foo() #[1,1]print(xyz) # NameError,当前作用域没有xyz变量 为什么第二次调用foo(）函数打印的是[1,1]?12345678910111213141516171819202122 - 因为函数也是对象，Python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期 - 查看 foo.__defaults__ 属性，__defaults__中使用元组保存默认值 - xyz 是引用类型，引用类型的元素变动，并不是元组的变化 - 属性__defaults__中使用元组保存所有位置参数默认值，它不会因为在函数内使用了它而发生改变 - 属性__kwdefaults__中使用字典保存所有keyword-only参数的默认值- 使用可变类型作为默认值，就可能修改这个默认值- 有时候这个特性是好的，有的时候这种特性是不好的，有副作用- 如何做到按需改变呢？看下面2种方法- - 第一种方法： - - 使用影子拷贝创建一个新的对象，永远不能改变传入的参数 - 第二种方法 - - 通过值的判断就可以灵活的选择创建或者修改传入对象 - 这种方式灵活，应用广泛 - 很多函数的定义，都可以看到使用None这个不可变的值作为默认参数，可以说这是一个惯用法 变量名解析原则LEGB12345- Local ， 本地作用域，局部作用域local命名空间。函数调用时创建，调用结束消亡- Enclosing，Python2.2 时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间- Global ，全局作用域， 即一个模块的命名空间。模块被 import 时创建，解释器退出时消亡- Build-in ， 内置模块的命名空间，生命周期从Python解释器启动时创建到解释器退出时消亡。例如print(open), print和open都是内置的变量- 所以一个变量的查找顺序就是LEGB 函数的销毁123456789101112- 全局函数销毁- - 重新定义同名函数 - del 语句删除函数名称，函数对象的引用计数减1 - 程序结束时- 局部函数销毁 - 在同级作用域同名函数下方重新定义同名函数 - del语句删除函数名称，函数对象的引用计数减1 - 上级作用域销毁时]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-类]]></title>
    <url>%2Fblog%2F2017%2F05%2F08%2FPython-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[定义​ 1、必须使用class关键字​ 2、类名必须使用大驼峰命名​ 3、类定义完成后就产生了一个类对象，绑定到了标识符ClassName上 类对象及类属性 类对象，类定义就会生成一个类对象 类的属性，类定义的变量和类中定义的方法都是类的属性 类变量，上例中x是类MyClass的变量 foo是方法对象Method，不是普通的函数对象function，它一般至少有一个参数，第一个参数可以是self（self只是个惯用标识符，可以换名字），这个参数位置就留给了self。 self指代当前实例本身 实例化每次实例化后获得的实例，是不同的实例，即使是同样的参数实例化，也得到不一样的对象。Python类实例化后，会自动调用init方法，这个方法第一个参数必须留给self，其他参数随意。 init 方法MyClass()实际上调用的是init(self) 方法，可以不定义，如果没有定义会在实例化后隐式调用作用：对实例进行初始化初始化函数可以接受多个参数，请注意第一个位置必须是self，例如init(self，name， age )注意：init() 方法不能有返回值，也就是只能是return None 实例对象 instance类实例化后一定会获得一个对象，就是实例对象init 方法的第一参数self就是指代某一个实例。类实例化后，得到一个实例对象，实例对象会绑定方法，调用方法是采用jerry.showage()的方式。self就是jerry，Python会把方法的调用这作为第一个参数self的实参传入。self.name 就是jerry对象的name，name保存在了jerry对象上，而不是Person类上，所以称为实例变量。 self上例说明，self就是调用者，就是c对应的实例对象。self 这个名字只是一个惯例，它可以修改，但是请不要修改，否则影响代码的可读性。 实例变量和类变量 实例变量是每一个实例自己的变量，是自己独有的；类变量是类的变量，是类所有实例共享的属性和方法。注意：Python中每一种对象都拥有不同的属性。函数、类都是对象，类的实例也是对象。 总结是类的，也是这个类所有实例的，其实实例都可以访问到；是实例的，就是这个实例自己的，通过类访问不到，类变量是属于类的变量，这个类的所有实例可以共享这个变量。​对象可以动态的给自己在增加一个属性，实例.dict[变量名]和实例.变量名都可以访问到，实例的同名变量会隐藏掉类变量，或者说覆盖了这个类变量。​实例属性的查找顺序​ 指的就是实例使用 .点号来访问属性，会先找自己的dict ，如果没有，然后通过属性class找到自己的类，再去类的dict中找。​ 注意，如果实例使用dict[变量名] 访问变量，将不会按照上面的查找顺序找变量，这是指明使用字典的key查找，不是属性查找。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Demo_七段数码管绘制]]></title>
    <url>%2Fblog%2F2017%2F04%2F28%2FPython-%E4%B8%83%E6%AE%B5%E6%95%B0%E7%A0%81%E7%AE%A1%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数码管是一种半导体发光器件，数码管可分为七段数码管和八段数码管，区别在于八段数码管比七段数码管多一个用于显示小数点的发光二极管单元DP（decimal point）。它价格便宜、使用简单，通过对其不同的管脚输入相对的电流，使其发亮，从而显示出数字能够显示 时间、日期、温度等所有可用数字表示的参数的器件。在电器特别是家电领域应用极为广泛，如显示屏、空调、热水器、冰箱等等。本案例使用turtle库实现，首先了解下turtle的使用方法 turtle的空间体系1，绝对坐标体系，中心是（0,0）就是我们初中就开始学的绝对坐标体系2，相对坐标体系，turtle是海龟，头部朝向左侧为正，右侧朝向为负的一个体系 turtle的颜色控制体系1，可以用一些默认的颜色来控制2，可以用最大值255或者最大值为1来控制，切换方式为turtle.colormode(255)或者turtle.colormode(1)来控制 turtle的运动控制函数1，turtle.fd(d)走直线，行进距离是d2，turtle.circle(r,angle) 绘制一个图形，r是半径，angle是弧形的角度，如果r是正数，则表示圆心在tutle的左侧，如果r是负数，则表示圆心在turtle的右侧3，turtle.speed(x) x的取值从0到10，越大速度越快4，turtle.goto(x,y)可以把画笔直接移动到绝对坐标体系的某一个点 turtle的运动方向控制函数1，seth(angle) 将turtle当前的方向设置为绝对坐标下的angle角度2，left(angle) 将turtle朝向设置为海龟当前朝向左侧的angle2，right(angle) 将turtle朝向设置为海龟当前朝向右侧的angle turtle的流程控制1，turtle画笔默认首先在中心的位置。并且画笔是放下状态2，turtle.penup() 抬起画笔3，turtle.pendown() 放下画笔4，turtle.pensize() 设置画笔的粗细5，turtle.pencolor() 设置画笔的颜色6，turtle.done()表示状态，运行完之后不会退出，需要手动退出，如果不加入的话，turtle画布会自动退出7，turtle.write(c,font=(“Arial”,18,”normal”))来写文字c，包括汉字8，turtle.hideturtle()函数可以隐藏turtle的的画笔 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import turtle,timedef drawGap(): turtle.penup() turtle.fd(5)def drawLine(draw): drawGap() turtle.pendown() if draw else turtle.penup() turtle.fd(40) drawGap() turtle.right(90)def drawDigit(digit): drawLine(True) if digit in [2,3,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,1,3,4,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,6,8] else drawLine(False) turtle.left(90) drawLine(True) if digit in [0,4,5,6,8,9] else drawLine(False) drawLine(True) if digit in [0,2,3,5,6,7,8,9] else drawLine(False) drawLine(True) if digit in [0,1,2,3,4,7,8,9] else drawLine(False) turtle.left(180) turtle.penup() turtle.fd(20)def drawDate(date): turtle.pencolor(&apos;red&apos;) for i in date: if i == &apos;-&apos;: turtle.write(&apos;年&apos;,font=(&apos;Arial&apos;,18,&apos;normal&apos;)) turtle.pencolor(&apos;green&apos;) turtle.fd(40) elif i == &apos;=&apos;: turtle.write(&apos;月&apos;,font=(&apos;Arial&apos;,18,&apos;normal&apos;)) turtle.pencolor(&apos;blue&apos;) turtle.fd(40) elif i == &apos;+&apos;: turtle.write(&apos;日&apos;,font=(&apos;Arial&apos;,18,&apos;normal&apos;)) else: drawDigit(eval(i))def main(): turtle.setup(800,350,200,200) turtle.speed(10) # 设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。 turtle.pensize(5) turtle.penup() turtle.fd(-300) drawDate(time.strftime(&apos;%Y-%m=%d+&apos;, time.gmtime())) turtle.hideturtle() # 隐藏画笔的turtle形状 turtle.done()if __name__ == &apos;__main__&apos;: main() 效果图 参考：中国大学MOOC网 《Python语言程序设计》]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-List]]></title>
    <url>%2Fblog%2F2017%2F04%2F22%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-list%2F</url>
    <content type="text"><![CDATA[列表 一个队列，一个排序整齐的队伍 列表内的个体称为元素，由若干元素组成列表 元素可以是任意对象（数字，字符串，对象，列表等） 列表内元素有顺序，可以使用索引 线性的数据结构 使用[]表示 列表是可变的 列表、链表、queue（队列）、stack（栈）的差异链表 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。 queue 队列是一种特殊的线性表，是一种先进先出（FIFO）的数据结构。它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。 stack 栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。 由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 列表list定义 初始化 list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterable’s items 列表不能一开始就定义大小 列表查询 index(value, [start, [stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 列表增加、插入元素 append(object) -&gt; None 列表尾部追加元素，返回None 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(1) insert(index, object) -&gt; None – insert object before index 在制定的索引index出插入元素object 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(n) 索引 超过上界，尾部追加5 超过下届，头部追加 extend(iterable) -&gt; None – extend list by appending elements from the iterable 将可迭代对象的元素追加进来，返回None 就地修改 + -&gt; list 连接操作，将两个列表连接起来 产生新的列表，原列表不变 本质上调用的是add()方法 * -&gt; list 重复操作，将本列表元素重复n次，返回新的列表 列表删除元素 remove(value) -&gt; None – remove first occurrence of value. 从左至右查找第一个匹配value的值，移除该元素，返回None 就地修改 效率O(n)，每删除一个元素其后面的元素都要往前移动 pop([index]) -&gt; item – remove and return item at index (default last). 不指定索引index，就从列表尾部弹出一个元素 指定索引index，就从索引出弹出一个元素，索引超界抛出IndexError错误 效率O(1)，指定索引的时间复杂度O(n)，不指定索引O(1) clear() -&gt; None – remove all items from L 清除列表所有元素，剩下一个空列表]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-set]]></title>
    <url>%2Fblog%2F2017%2F04%2F13%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-set%2F</url>
    <content type="text"><![CDATA[含义 set翻译为集合 collection翻译为集合类型，是一个大概念 SET 可变的、无序的、不重复的元素的集合 set定义 初始化 set() -&gt; new empty set object set(iterable) -&gt; new set object s = {} 是字典，不是集合 set的元素 set的元素要求必须可以hash 目前学过的不可hash的类型有list、set 元素不可以索引 set可以迭代 set增加 add(elem) 增加一个元素到set中 如果元素存在，什么都不做 update(*others) 合并其他元素到set集合中 参数others必须是可迭代对象 就地修改 set删除 remove(elem) 从set中移除一个元素 元素不存在，抛出KeyError异常。 discard(elem) 从set中移除一个元素 元素不存在，什么都不做 pop() -&gt; item 移除并返回任意的元素。 空集返回KeyError异常 clear() 移除所有元素 set修改、查询 修改 要么删除，要么加入新的元素 为什么没有修改？ 查询 非线性结构，无法索引 遍历 可以迭代所有元素 set和线性结构 线性结构的查询时间复杂度是O(n)，随着数据规模的增大而增加耗时 set、dict 等结构，内部使用hash值作为key，时间复杂度可以做到O(1)，查询时间和数据规模无关 可hash 数值型int、float、complex 布尔型True、False 字符串string、bytes tuple None 以上都是不可变类型，成为可哈希类型，hashable set的元素必须是可hash 集合 全集 所有元素的集合。例如实数集，所有实数组成的集合就会全集 子集subset和超集superset 一个集合A所有元素都在另一个集合B内，A是B的子集，B是A的超集 真子集和真超集 A是B的子集，且A不等于B，A就是B的真子集，B是A的真超集 并集：多个集合合并的结果 交集：多个集合的公共部分 差集：集合中除去和其他集合公共部分 集合运算 并集 将两个集合A和B的所有元素合并到一起，组成的集合称作A与B集合的并集 union(*others) 返回和多个集合合并后的新的集合 | 运算符重载 等同union update(*other) 和多个集合合并，就地修改 |= 等同update 交集 集合A和B，由所有属于A且属于B的元素组成的集合 intersection(*others) 返回和多个集合的交集 &amp; 等同intersection intersection_update(*others) 获取和多个集合的交集，并就地修改 &amp;= 等同intersection_update 差集 集合A和B，由所有属于A且不属于B的元素组成的集合 difference(*others) 返回和多个集合的差集 - 等同difference difference_update 获取和多个集合的差集并就地修改 等同difference_update 对称差集 集合A和B，由所有不属于A和B的交集元素组成的集合，记作(A-B)∪(B-A) symmetric_difference(other) 返回和另一个集合的差集 ^ 等同symmetric_difference symmetric_difference_update(other) 获取和另一个集合的差集并就地修改 ^= 等同symmetric_difference_update 子集与超集 issubset(other)、&lt;= 判断当前集合是否是另一个集合的子集 set1&lt;set2 判断set1是否是set2的真子集 issuperset(other)、&gt;= 判断set1是否是set2的真超集 set1 &gt; set2 判断set1是否是set2的真超集 isdisjoint(other) 当前集合和另一个集合没有交集 没有交集，返回True]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-tuple]]></title>
    <url>%2Fblog%2F2017%2F04%2F07%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-tuple%2F</url>
    <content type="text"><![CDATA[元组 一个有序的元素组成的集合 使用小括号（）表示 元组是不可变对象 定义 tuple() -&gt; empty tuple tuple(iterable) -&gt; tuple initialized from iterable’s items t=(1,) # 一个元组的定义，注意有个逗号 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率降低 元组是只读的，所以增、删、改方法都没有 命名元组 namedtuplenamedtuple (typename, field_names, *, verbose=False, rename=False, module=None) 命名元组，返回一个元组的子类，并定义了字段 field_names 可以是空白符或逗号分割的字符串，可以是字段的列表 &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Point = namedtuple(&apos;_Point&apos;,[&apos;x&apos;,&apos;y&apos;]) &gt;&gt;&gt; P = Point(11,22) &gt;&gt;&gt; Student = namedtuple(&apos;Student&apos;,&apos;name age&apos;) &gt;&gt;&gt; Tom = Student(&apos;tom&apos;,20) &gt;&gt;&gt; Jerry = Student(&apos;jerry&apos;,18) &gt;&gt;&gt; tom.name &apos;tom&apos; &gt;&gt;&gt; &gt;&gt;&gt; jerry.age 18 &gt;&gt;&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Tuple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-字典]]></title>
    <url>%2Fblog%2F2017%2F04%2F02%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[字典 dict key-value键值对的数据的集合 可变的、无序的、key不重复 字典dict定义 初始化 d = dict() 或者 d={} dict(**kwargs) 使用name=value对 初始化一个字典 dict(iterable, **kwargs) 使用可迭代对象和name=value对构造字典，不过可迭代对象的元素必须是一个二元组 d = dict(((1,’a’),(2,’b’))) 或者 d = dict(([1,’a’],[2,’b’])) dict(mapping,**kwarg) 使用一个字典构建另一个字典 d={‘a’:10,’b’:20,’c’:None,’d’:[1,2,3]} 类方法dict.fromkeys(iterable,value) d=dict.fromkeys(range(5)) d=dict.fromkeys(range(5),0) 字典元素的访问 d[key] 返回key对应的值value key不存在抛出KeyError异常 get(key[,default]) 返回key对应的值value key不存在返回缺省值，如果没有设置默认缺省值就返回None setdefault(key[,default]) 返回key对应的值value key不存在，添加kv对，value设置为default，并返回default，如果default没有设置，缺省为None 字典增加和修改 d[key] = value 将key对应的值修改为value key不存在添加新的kv对 update[other] -&gt; other 使用另一个字典的kv对更新本字典 key不存在，就添加 key存在，覆盖已经存在的key对应的值 就地修改 d.update(red=1) d.update(((‘red’,2),)) d.update({‘red’:3}) 字典删除 pop(key[,default]) key存在，移除它，并返回它的value key不存在，返回给定的default default未设置，key不存在则抛出KeyError异常 clear() 清空字典 del语句 d = {‘a’:1, ‘b’:b, ‘c’:[1,3,5]} del d[‘c’] #看着像删除了一个对象，本质上减少了一个对象的引用，del实际上删除的是名称，二不是对象 字典遍历Python3中，key、values、items方法返回一个类似一个生成器的可迭代对象，不会吧函数的返回结果复制到内存中 Dictionary view 对象，可以使用len()、iter()、in()操作 字典的entry的动态的视图，字典变化，视图将反应出这些变化 keys返回一个类set对象，也就是看着一个set集合。如果values都可以hash，那么itens也可以看做是类set对象 python2中，上面的方法会返回一个新的列表，占据新的内存空间。所以python2建议使用iterkeys、itervalues、iteritems版本，返回一个迭代器，而不是返回一个copy 字典遍历和移除 如何在遍历的时候移除元素 12345678d = dict(a=1,b=2,c='abc')keys = []for k,v in d.items(): if isinstance(v, str): keys.append(k)for k in keys: d.pop(k)print(d) 字典的key key的要求和set的元素要求一致 set的元素可以就是看做key，set可以看做dict的简化版 hashable可哈希才可以作为key，可以使用hash()测试 d = {1:0， 2.0:3， ‘abc’:None, (‘’hello’,’world’,’python’:’string’, b’abc’:’135’) } defaultdict collections.defaultdict([default_factory[,…]]) 第一个参数是default_factory，缺省是None，它提供一个初始化函数。当key不存在的时候，会调用这个工厂函数来生成key对应的value 12345678910111213141516import randomd = &#123;&#125;for k in 'abcdef': for i in range(random.randint(1, 5)): if k not in d.keys(): d[k] = [] d[k].append(i)print(d)## 使用defaultdict函数from collections import defaultdictd = defaultdict(list)for k in 'abcdef': for i in range(random.randint(1,5)): d[k].append(i)print(d) OrderedDict collections.OrderedDict([items]) 有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印 3.6版本的Python的字典就是记录key插入的顺序（IPython不一定效果） 应用场景： 加入使用字典记录N个产品，这些产品使用ID从小到大加入到字典中 除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为顺序是有序的 否则还需要重新把遍历到的值排序]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>DICT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-字符串]]></title>
    <url>%2Fblog%2F2017%2F03%2F23%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[定义 一个个字符组成的有序的序列，是字符的集合 使用单引号、双引号、三引号 字符串是不可变对象 Python3起，字符串就是Unicode类型 字符串join连接 ‘string’.join(iterable) -&gt; str 将可迭代对象连接起来，使用string作为分隔符 可迭代对象本身的元素都是字符串 返回一个新的字符串 字符串+连接 + -&gt; str 将2个字符串连接在一起 返回一个新的字符串 字符串分割分割字符串的方法分为两类 split系 将字符串按照分隔符分割成若干字符串，并返回 列表 split(sep=None, maxsplit=-1) -&gt; list of strings 从左至右 sep指定分割字符串，缺省的情况下空白字符作为分隔符 maxsplit指定分割的次数，-1表示遍历整个字符串 rsplit(sep=None, maxsplit=-1) -&gt; list of strings 从右至左 sep指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit指定分割的次数，-1表示遍历整个字符串 splitlines([keepends=False]) -&gt; list of strings 按照行来切分字符串 keepends指的是否保留行分隔符 行分隔符包括\n、\r\n、\r 等 partition系 将字符串按照分隔符分割成2段，返回这2段和分隔符的元组 partition(sep) -&gt; (head,sep,tail) 从左至右，遇到分隔符就把字符串分割成两部分，返回头，分隔符、尾三部分的三元组；如果没有找到分隔符，就返回头、2个空元素的三元组 sep分割字符串，必须制定 rpartition(sep) -&gt; (head,sep,tail) 从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回2个空元素和尾的三元组 字符串大小写 upper() 全大写 lower() 全小写 大小写，做判断的时候用 swapcase() 交互大小写 字符串修改 replace(old,new[,count]) - str 字符串中找到匹配替换为新子串，返回新字符串 count表示替换几次，不指定就是全部替换 strip([char]) -&gt; str 从字符串两端去除指定的字符集chars中的所有字符 如果chars没有指定，去除两端的空白字符 lstrip([char]) -&gt; str 从左开始 rstrip([char]) -&gt; str 从右开始 字符串查找 find(sub[,start[,end]]) -&gt; int 在指定的区间[start[,end]]，从左至右，查找子串sub，找到返回索引，没有找到返回-1 rfind(sub[,start[,end]]) -&gt; int 在指定的区间[start[,end]]，从左至，查找子串sub，找到返回索引，没有找到返回-1 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 字符串判断 endswith(suffix[, start[, end]]) -&gt; bool 在指定的区间[start,end]，字符串是否是suffix结尾 startswith(prefix[, start[, end]]) -&gt; bool 在指定的区间[start，end]，字符串是否是prefix开头 字符串判断is系列 isalnum() -&gt; 是否是字母和数字组成 isalpha() -&gt; 是否是字母 isdecimal() -&gt; 是否包含十进制数字 isdigit() -&gt; 是否全部是数字（0~9） isdentifier() -&gt; 是不是字母和下划线开头，其他都是字母、数字、下划线 islower() -&gt; 是否都是小写 isupper() -&gt; 是否全部大写 isspace() -&gt; 是否只包含空白字符串]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Str</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-数据结构-字节]]></title>
    <url>%2Fblog%2F2017%2F03%2F16%2FPython-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E8%8A%82%2F</url>
    <content type="text"><![CDATA[bytes 不可变字节序列 bytearray 字节数组 可变 字符串与bytes 字符串是字符组成的有序序列，字符可以使用编码来理解 bytes是字节组成的有序的不可变序列 bytearray是字节组成的有序的可变序列 编码与解码 字符串按照不同的字符集编码encode 返回字节序列bytes encode(encoding=’utf-8’，errors=’strict’) -&gt; bytes 字节序列按照不同的字符集解码decode返回字符串 bytes.decode(encoding=’utf-8’,errors=’strict’) -&gt; str bytearray.decode(encoding=’utf-8’,errors=’strict’) -&gt; str bytes定义 十六进制的字符串表示方法是“\x”,十六进制数的时候用“0x”表示 bytes() -&gt; 空bytes bytes(int) -&gt; 指定字节的bytes，被0填充 bytes(iterable_of_ints) -&gt; bytes[0,255]的int组成的可迭代对象 >&gt;&gt; bytes(range(0,5)) ​ b’\x00\x01\x02\x03\x04’ bytes(string,encoding[,errors]) -&gt; bytes等价于string.encode() bytes(bytes_or_buffer) -&gt; immutable copy of bytes_of_buffer 从一个字节序列或者buffer复制出一个新的不可变的bytes对象 使用b前缀定义 只允许基本ASCII使用字符形式b’abc9’ 使用16进制表示b’\x41\x61’ >&gt;&gt; b’\x41\x61’.decode() ​ ‘Aa’ bytes操作 和str类型类似，都是不可变类型，所以很多都是一样。只不过bytes的方法，输入的是bytes，输出是bytes bytes b’abcdef’.replace(b’f’,b’k’) b’abc’.find(b’b’) 类方法bytes.formhex(string) string必须是2个字符的16 进制的形式，’6162 6a 6b’，空格将被忽略 bytes.fromhex(‘6162 09 6a 6b00’) hex() 返回16进制表示的字符串 ‘abc’.encode().hex() 索引 b’abcdef’[2] 返回该字节对应的数，int类型 bytearray 定义 bytearray() -&gt;空bytearray bytearray(int) -&gt; 指定字节的bytearray, 被0填充 bytearray(iterable_of_ints) -&gt;bytearray[0,255]的int组成的可迭代对象 bytearray(string,encoding[,errors]) -&gt; bytearray近似string.encode()，不过返回可变对象 bytearray(bytes_or_buffer) 从一个字节序列或者buffer复制出一个新的可变bytearray对象 注意，b前缀定义的类型是bytes类型 bytearray操作 append(int) 尾部追加一个元素 insert(index,int) 在指定索引位置插入元素 extend(iterable_of_ints) 将一个可迭代的整数集合追加到当前bytearray pop(index=-1)从指定索引上移除元素，默认从尾部移除 remove(value)找到第一个value移除，找不到抛ValueError异常 注意：上述方法若需要使用int类型，值在[0,255] clear()清空bytearray reverse()翻转bytearray，就地修改 int 和 bytes int.from_bytes(bytes,byteorder) 将一个字节数组表示成整数 int.to_bytes(leng,byteorder) byteorder 字节序 将一个整数表达成一个指定长度的字节数组 12345678&gt;&gt;&gt; i = int.from_bytes(b'abc','big')&gt;&gt;&gt; i6382179&gt;&gt;&gt;&gt;&gt;&gt; print(i,hex(i))6382179 0x616263&gt;&gt;&gt; print(i.to_bytes(3,'big'))b'abc' ASCII ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套计算机编码系统。它主要用于显示现代英语，而其扩展版本EASCII则可以部分支持其他西欧语言，并等同于国际标准ISO/IEC 646。其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符。用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>bytes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[format方法]]></title>
    <url>%2Fblog%2F2017%2F03%2F10%2Fformat%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[从Python2.6开始新增了一个格式化字符串函数str.format，它增强了字符格式化功能。 基本语法是通过{}和:来代替以前的%。format函数可以接受多个参数，参数的位置可以不按顺序。 12345678&gt;&gt;&gt; &apos;&#123;&#125; &#123;&#125;&apos;.format(&apos;hello&apos;,&apos;world&apos;) # 不设置指定位置，则按默认顺序&apos;hello world&apos;&gt;&gt;&gt; &apos;&#123;0&#125; &#123;1&#125;&apos;.format(&apos;Hello&apos;,&apos;world&apos;) # 设置指定位置&apos;Hello world&apos;&gt;&gt;&gt; &apos;&#123;1&#125; &#123;0&#125; &#123;1&#125;&apos;.format(&apos;Hello&apos;,&apos;world&apos;) # 设置指定位置&apos;world Hello world&apos; 123456789101112&gt;&gt;&gt; print(&apos;网站名：&#123;name&#125; \t地址：&#123;url&#125;&apos;.format(name=&apos;百度&apos;,url=&apos;www.baidu.com&apos;))网站名：百度 地址：www.baidu.com# 通过字典设置参数&gt;&gt;&gt; site = &#123;&apos;name&apos;:&apos;百度&apos;,&apos;url&apos;:&apos;www.baidu.com&apos;&#125;&gt;&gt;&gt; print(&apos;网站名：&#123;name&#125; \t 地址：&#123;url&#125;&apos;.format(**site))网站名：百度 地址：www.baidu.com# 通过列表设置参数&gt;&gt;&gt; nList = [&apos;百度&apos;,&apos;www.baidu.com&apos;]&gt;&gt;&gt; print(&apos;网站名：&#123;0[0]&#125; \t 地址：&#123;0[1]&#125;&apos;.format(nList))网站名：百度 地址：www.baidu.com 数字格式化123&gt;&gt;&gt; print(&apos;&#123;:.2f&#125;&apos;.format(3.1415926))3.14&gt;&gt;&gt; 选项 含义 &#39;&lt;&#39; 强制该字段在可用空间内左对齐（这是大多数对象的默认值）。 &#39;&gt;&#39; 强制字段在可用空间内右对齐（这是数字的默认值）。 &#39;=&#39; 强制将填充放置在符号（如果有）之后但在数字之前。这用于以“+000000120”形式打印字段。此对齐选项仅对数字类型有效。当‘0’紧接在字段宽度之前时，它变为默认值。 &#39;^&#39; 强制字段在可用空间中居中。 &#39;+&#39; 表示正号和负号都应使用符号。 &#39;-&#39; 表示符号应仅用于负数（这是默认行为）。 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 {} 来转义大括号，如下实例：12&gt;&gt;&gt; print (&quot;&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;&quot;.format(&quot;runoob&quot;))runoob 对应的位置是 &#123;0&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>格式化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库_总结]]></title>
    <url>%2Fblog%2F2017%2F02%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、数据库的一些概念数据库的概念： 数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。 数据库管理系统： 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。例如:MySQL就是一个数据库管理系统。 关系数据库： 所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 关系数据库管理系统的特点： 数据以表格的形式出现; 每行为各种记录名称; 每列为记录名称所对应的数据域; 许多的行和列组成一张表单; 若干的表单组成 database; 关系模型的结构的一些概念： 表的结构 表 关系模型的数据结构单一，采用二维表结构来表示实体和实体之间的关系，是一种按行与列排列的具有相关信息的逻辑组。一个关系对应一个二维表。一个数据库可以包含任意多个数据表。 属性 表中每一列（也称字段、数据项）描述实体集的某个特征，在关系数据库中被称为属性；每一个属性都有自己的取值范围，称为域。 元组 表中的每一行由一个实体的相关属性取值构成，称为元组，它相对完整地描述了一个实体。一个元组在关系数据库中也被称为一条记录。元组的一个属性值称为分量。 关键字 在一个关系模式中，关键字是保证表中记录具有唯一性的一种机制。 候选关键字 关系表中按应用语义能唯一标志元组的最小属性的集合。在最简单的情况下，候选关键字只包含一个属性。在最极端的情况下，关系模式的所有属性组是这个关系模式的候选关键字，称为全码。 主关键字（主键） 用户指定的用来在关系表中唯一标识元组的一个候选关键字。若一个关系有多个候选关键字，则只选定其中的一个为主关键字。主关键字的值不能为空、不能重复。 外关键字 （外键） 一个表中的主关键字与另一个表中与该主关键字相同的属性建立联系，这个起到联系作用的属性，称为另一个表的外关键字，简称外键。 关系模式 表中的行定义（即表头）是实体集相关属性的集合，称为该表的关系模式。关系模式就是对关系的描述，包括关系名、组成该关系的属性名、属性向域的映像。 关系模式通常记为：(属性名1,属性名2,…属性名n)，其中主关键字加下划线。 二、关系数据库的基本操作关系数据库的基本操作包括：查、增、删、改。这些操作，我们可以通过一种语言去执行，这种语言就是 SQL （Structured Query Language），即结构化查询语言。 SQLSQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。 数据操作语言 (DML) SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。查询和更新指令构成了 SQL 的 DML 部分： SELECT - 从数据库表中获取数据 UPDATE - 更新数据库表中的数据 DELETE - 从数据库表中删除数据 INSERT INTO - 向数据库表中插入数据 数据定义语言 (DDL) SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句: CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SQL指令SELECT SELECT 最常用的方式是将数据从数据库中的表中选出，即从 (FROM) 数据库中的表中选出 (SELECT)。(表格是一个数据库内的结构，它的目的是储存数据。)一个最基本的 SQL 架构如下所示： SELECT “列名” FROM “表名称” 例如：1SELECT Name FROM city; 上述语句，会返回表 city 中的 Name 这一列的全部值。 DISTINCT SELECT 指令让我们能够读取表中一个或数个列的所有数据，得到的数据的值可能会有重复。当我们需要找出表中的某列数据有哪些不同的值时，只要在 SELECT 后加上一个 DISTINCT 就可以了。也就是说 SELECT 会将符合条件的数据全都选出来，而 DISTINCT 会选择出这个表的列中那些 不同的值。即使每个值的出现多次，使用 DISTINCT 后会返回唯一不同的值。在 SQL 中，使用 DISTINCT 的语法如下： SELECT DISTINCT “列名” FROM “表名称” 例如：1SELECT DISTINCT Language FROM countrylanguage; 上述语句，会返回表 countrylanguage 中的属性 Language 这一列在表中的不同的值。 WHERE 当我们需要选择性地从表中选取数据时，就需要用到 WHERE 这个指令。使用 WHERE 指令的语法如下： SELECT “列名称” FROM “表名称” WHERE “条件”（列 运算符 值） 例如：1SELECT CountryCode FROM countrylanguage WHERE Language = "English"; 上述语句，会返回表 countrylanguage 中 Language 的值为 Enlish 的 CountryCode 的列。 AND OR 上面的指令都是基于一个条件对数据进行选择，当我们想通过复杂条件选择数据时，可以将多个简单条件连接成复杂条件。拿 WHERE 来说，AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。使用 AND OR 指令的语法如下： SELECT “列名” FROM “表名称” WHERE “简单条件” {[AND|OR] “简单条件”}+ 例如： 1SELECT CountryCode FROM countrylanguage WHERE Language = English AND IsOfficial = "T"; 上述语句，会返回表 countrylanguage 中 Language 的值为 Enlish 且 IsOfficial 为 T 的列。 IN IN 这个指令允许我们在 WHERE 子句中规定多个值。IN 指令的语法为下： SELECT “栏位名” FROM “表名称” WHERE “列名” IN (‘值一’, ‘值二’, …) 例如： 1SELECT CountryCode FROM countrylanguage WHERE Language IN ("Enlish","French"); 上述命令，会返回表 countrylanguage 中 Language 的值满足条件在 Enlish 和 French 这两个值中的列。 BETWEEN BETWEEN 操作符在 WHERE 子句中使用，经常和 AND 连用。使用 BETWEEN … AND 选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。。BETWEEN 这个子句的语法如下： SELECT “列名” FROM “表名称” WHERE “列名” BETWEEN ‘值一’ AND ‘值二’ 例如：1SELECT CountryCode FROM countrylanguage WHERE Percentage BETWEEN "10.0" AND "35.0"; 上述语句，会返回表 countrylanguage 中 Percentage 值在 10.0 到 35.0 之间的列。 LIKE LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式(pattern)。对比之下，在使用 IN 指令的时候，我们完全地知道我们需要的条件；在使用 BETWEEN 指令的时候，我们则是列出一个范围。使用 LIKE 指令的语法如下： SELECT “列名” FROM “表名称” WHERE “列名” LIKE {模式} 例如： 1SELECT CountryCode FROM countrylanguage WHERE CountryCode LIKE "%A%"; 上述语句，会返回表 countrylanguage 中 CountryCode 以A开头的列。LIKE 后的模式，通常是一个通配符。 ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序,默认按照升序（ASC）对记录进行排序。如果希望按照降序对记录进行排序，可以使用 DESC 关键字。ORDER BY 的语法如下: SELECT “列名” FROM “表名称” [WHERE “条件”] ORDER BY “列名” [ASC, DESC] 例如： 1SELECT CountryCode,Percentage FROM countrylanguage WHERE Percentage BETWEEN "25.0" AND "55.0" ORDER BY Percentage DESC; 上述语句，会返回表 countrylanguage 中包含 CountryCode 和 Percentage 的列，这些列按照 Percentage 的值降序排列，且满足 Percentage 值介于25.0和55.0之间。 函数 除了对数据的查询，我们有的时候可能会想对这些数据做一些运算，比如将它们总合起来，或是找出它们的平均值，而SQL 有提供一些这一类的函数。 AVG (平均) COUNT (计数) MAX (最大值) MIN (最小值) SUM (总合) 使用函数的语法是： SELECT “函数名”(“列名”) FROM “表名称” 例一： 1SELECT SUM(Population) FROM city WHERE CountryCode = "AFG"; 上述语句，会返回表 city 中 CountryCode 等于 AFG 的 Population 总合。 例二： 1SELECT COUNT(CountryCode) FROM city WHERE CountryCode = "NLD"; 上述语句，会返回表 city 中 CountryCode 等于 NLD 的个数。 例三： 1SELECT COUNT(DISTINCT CountryCode) FROM city WHERE CountryCode IS NOT NULL; 上述语句，会返回表 city 中 CountryCode 的个数。COUNT 和 DISTINCT 经常被合起来使用，目的是找出表中某列有多少不同的数值。 例四： 1SELECT AVG(Population) FROM city WHERE CountryCode = "DZA"; 上述语句，会返回表 city 中 CountryCode 等于 DZA 的Population 的平均值。 GROUP BY GROUP BY 语句用于结合合计函数 (比如 SUM)，根据一个或多个列对结果集进行分组。使用 GROUP BY 的语法为： SELECT “列名1”, SUM(“列名2”) FROM “表名称” GROUP BY “列名1” 例如： 1SELECT CountryCode,SUM(Population) FROM city GROUP BY CountryCode; 上述语句，会返回表 city 中 每个 CountryCode 对应的总人数，结果按照 CountryCode 进行分组。 HAVING 当我们想对函数产生的值来设定条件时，比如我们想知道那个 CountryCode 的总人数超过10000000，在这个情况下，我们不能使用 WHERE 的指令。这时，我们可以使用 HAVING 的指令，来达到这个目标。 需要注意的是 HAVING 子句通常是在一个 SQL 句子的最后；而且，一个含有 HAVING 子句的 SQL 并不一定要包含 GROUP BY 子句。使用 HAVING 的语法如下： SELECT “列名1”, SUM(“列名2”) FROM “表名称” GROUP BY “列名1” HAVING (函数条件) 例如： 1SELECT CountryCode,SUM(Population) FROM city GROUP BY CountryCode HAVING SUM(Population) &gt; "10000000"; 上述语句，会返回表 city 中 Population 总数大于10000000的结果，结果按照 CountryCode 进行分组。 ALIAS 在 SQL 语言中，可以通过 ALIAS 为列名称和表名称指定别名。最常用到的别名有两种：列别名及表别名。SQL 中使用列名和表别名的语法如下： SELECT “表别名”.”列名1” “列别名” FROM “表名称” “表别名” 例如： 1SELECT c1.District Area FROM city c1 GROUP BY c1.District; 上述语句，会返回表 city 中的 District 这一列。不同的是，返回的结果中 District 这一列有了别名 Area。 表连接 之前，我们都是在一张表中读取数据，操作相对比较简单。但实际情况下，我们经常需要从多个数据表中读取数据。在 SQL 中，JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 在 MySQL 中 JOIN 按照功能大致分为如下三类： INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。 RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。 要能进行多表查询，那么被查询的表之间必须要有联系，而数据库中的表可通过键将彼此联系起来。 主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。 例如： 12345678SELECT c1. NAME CountryName, c2. LANGUAGE Country_LanguageFROM city c1INNER JOIN countrylanguage c2 ON c1.CountryCode = c2.CountryCodeGROUP BY c1. NAME; 注： INNER JOIN 与 JOIN 是相同的。 表格处理前面我们基本都是在数据库管理系统中存在数据库的情况下，获取数据库中的数据。当然，我们也可以自己创建数据库，根据自己的需要建表存储数据。 CREATE DATABASE 在 SQL 中，使用 CREATE DATABASE 来创建数据库。使用的语法 CREATE DATABASE 语法如下： CREATE DATABASE database_name 例如： 1CREATE DATABASE store; 上述语句，创建了一个名叫 store 的数据库。 CREATE TABLE 创建好数据库，我们就需要建立表格来存储数据。使用 CREATE TABLE 的语法是： CREATE TABLE 表名称 ( 列名称1 数据类型, 列名称2 数据类型, 列名称3 数据类型, …. ) 例如： 12345678CREATE TABLE Customer( Id int, First_Name char(50), Last_Name char(50), Address char(50), City char(50), Country char(25), Birth_Date date ); 上述语句，创建了一个名叫 Customer 的表,并定义了表中存储数据。 在创建表时，我们需要对表中要存储的数据进行限制，常见的限制有以下几种： NOT NULL UNIQUE CHECK Primary Key Foreign Key NOT NULL 在没有做出任何限制的情况下，某一列的值是允许有 NULL 值的。如果我们不允许某一列的值含有 NULL 值，我们就需要对那个列做出 NOT NULL 的指定。 例如： 1234CREATE TABLE Customer( SID integer NOT NULL, Last_Name varchar (30) NOT NULL, First_Name varchar(30)); 上述语句，”SID” 和 “Last_Name” 这两列不允许有 NULL 值，而 “First_Name” 这一列是可以有 NULL 值的。 UNIQUE UNIQUE 限制是保证一个栏位中的所有资料都是有不一样的值。 例如： 1234CREATE TABLE Customer( SID integer Unique, Last_Name varchar (30), First_Name varchar(30)); 上述语句，”SID” 这列不能有重复值存在，而 “Last_Name” 及 “First_Name” 这两列则是允许有重复值存在。 注意：一个被指定为主键的列也一定会含有 UNIQUE 的特性。相对来说，一个UNIQUE 的列并不一定会是一个主键。 CHECK CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。 例如： 1234CREATE TABLE Customer( SID integer CHECK (SID &gt; 0), Last_Name varchar (30), First_Name varchar(30)); 上述语句，”SID” 这列的值只能包含大于 0 的整数。 注意：CHECK 限制目前尚未被执行于 MySQL 数据库上。 Primary Key 主键（Primary Key）在前面已经多次提到了，它是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。主键可以是表中的一个列，或是一个人造列 (与表没有关系的列)。主键可以包含一或多个列。当主键包含多列时，称为组合键 (Composite Key)。 主键可以在创建新表时设定 (使用 CREATE TABLE 语句)，或是以改变现有表架构的方式设定 (使用 ALTER TABLE)。例如，MySQL 中指定 Primary Key： 12345CREATE TABLE Customer( SID integer, Last_Name varchar(30), First_Name varchar(30), PRIMARY KEY (SID)); 或者是改变现有表架构的方式设定： 1ALTER TABLE Customer ADD PRIMARY KEY (SID); Foreign Key 外键（Foreign Key）是一个(或数个)指向另外一个表格主键的列。外键的目的是确定资料的参考完整性(referential integrity)。也就是说，只有被准许的资料值才会被存入数据库内。 例如，MySQL 中设置 Foreign Key： 1234567CREATE TABLE ORDERS( Order_ID integer, Order_Date date, Customer_SID integer, Amount double, Primary Key (Order_ID), Foreign Key (Customer_SID) references CUSTOMER(SID)); 同样的，在建好表之后，我们依然可以通过改变现有表架构的方式设定外键： 1ALTER TABLE ORDERS ADD FOREIGN KEY (customer_sid) REFERENCES CUSTOMER(sid); CREATE VIEW 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。SQL中，建立一个视图的语法如下： CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition 例如： 1CREATE VIEW New_City AS SELECT Name,District,Population FROM city; 这样，我们就有了一个名为 New_City 的视图。当然，我们可以从视图中获取数据： 1SELECT * FROM New_City; CREATE INDEX INDEX （索引）是由一个表中的一列或者若干列的值与其对应的记录在数据表中地址所组成。用户无法看到索引，它们只能被用来加速搜索/查询。 数据库中一个表的存储由两部分组成：数据页面和索引页面。 创建索引的目的是为了改善查询性能、加快依据索引字段对表中数据行的检索、强制保持表的数据唯一性等。 索引虽然能改善查询性能，但也耗费了磁盘空间，并且当对数据表进行数据增加、修改或删除时，系统需要花费一些时间来维护索引，所以通常不在一个表上建立太多索引，也不建立不常使用的索引。 一般来说，需要在下面这些地方建立索引： 在主键和外键上创建索引 在检索频繁的字段建立索引 在经常需要排序的字段上建立索引 在 SQL 中，建立索引的语法如下： CREATE INDEX “INDEX_NAME” ON “TABLE_NAME” (COLUMN_NAME) 例如： 1CREATE INDEX IDX_POPULATION ON city (Population); 注意索引的命名并没有一个固定的方式。通常会用的方式是在名称前加一个字首，例如”IDX_” ，来避免与数据库中的其他物件混淆。另外，在索引名之内包括表名及列名也是一个好的方式。 ALTER TABLE 在表被建立在数据库中后，我们常常会发现，这个表的结构需要有所改变。比如，增加一列、删去一列、改变列名称、改变列的数据类型。在 SQL 中， ALTER TABLE 语句用于在已有的表中添加、修改或删除列。使用 ALTER TABLE 的语法如下： ALTER TABLE “table_name” [ 改变方式 ] [ 改变方式 ] 的详细写法会依我们想要达到的目标而有所不同。比如，增加一列： 1ALTER TABLE city ADD Country char(10); 删除一列： 1ALTER TABLE city Drop Country; 改变列的类型： 1ALTER TABLE city Modify Country char(5); DROP 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。 例如，删除一个表： 1DROP TABLE city; 或者是删除一个索引： 1DROP INDEX IDX_POPULATION; TRUNCATE TABLE 使用 DROP TABLE 指令会删除表和表中的数据。而使用 TRUNCATE TABLE 的指令，表中的数据会完全消失，可是表本身会继续存在。 TRUNCATE TABLE 的语法为下： TRUNCATE TABLE “表格名” 例如： 1TRUNCATE TABLE city; INSERT INTO 到目前为止，我们都是操作如何把数据从表中取出。那么，怎么往表中添加数据呢？在 SQL 中，我们可以通过 INSERT INTO 向表中添加数据。使用 INSERT INTO 的语法如下： INSERT INTO “表格名” (“列1”, “列2”, …) VALUES (“值1”, “值2”, …) 或者,将其它表中的数据作为值： INSERT INTO “表格1” (“栏位1”, “栏位2”, …) SELECT “栏位3”, “栏位4”, … FROM “表格2”; 例如： 1INSERT INTO city (Name,CountryCode,District,Population) VALUES ("NanJing","CHN","JiangSu",82302000); UPDATE 我们有时候可能会需要修改表格中的数据。在这个时候，我们就需要用到 UPDATE 指令。这个指令的语法是： UPDATE “表名” SET “列名1” = [新值] WHERE {条件} 例如： 1UPDATE city SET Population = "1880000" WHERE Name = "Kabul" AND CountryCode = "AFG"; DELETE FROM 在某些情况下，我们会需要直接从数据库中去除一些数据。在 SQL 可以通过 DELETE FROM 指令来完成。它的语法是： DELETE FROM “表格名” WHERE {条件} 例如： 1DELETE FROM city WHERE Name = "MaiJi"; 进阶SQLUNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 的语法如下： [SQL 语句 1] UNION [SQL 语句 2] 例如： 1SELECT CountryCode FROM city UNION SELECT CountryCode FROM countrylanguage; UNION ALL UNION ALL 这个指令的目的也是要将两个 SQL 语句的结果合并在一起。 UNION ALL 和 UNION 不同之处在于 UNION ALL 会将每一笔符合条件的数据都列出来，无论资料值有无重复。UNION ALL 的语法如下： [SQL 语句 1] UNION ALL [SQL 语句 2] 例如： 1SELECT CountryCode FROM city UNION ALL SELECT CountryCode FROM countrylanguage; INTERSECT 和 UNION 指令类似，INTERSECT 也是对两个 SQL 语句所产生的结果做处理的。不同的地方是，UNION 是对结果做并集，而 INTERSECT 是交集。INTERSECT 的语法如下： [SQL 语句 1] INTERSECT [SQL 语句 2] 注： MySQL 中无此用法 MINUS MINUS 指令是运用在两个 SQL 语句上。它先找出第一个 SQL 语句所产生的结果，然后看这些结果有没有在第二个 SQL 语句的结果中。如果有的话，那这一笔数据就被去除，而不会在最后的结果中出现。如果第二个 SQL 语句所产生的结果并没有存在于第一个 SQL语句所产生的结果内，那这笔数据就被抛弃。MINUS，也就是差集。使用 MINUS 的语法如下： [SQL 语句 1] MINUS [SQL 语句 2] 注： MySQL 中无此用法 子查询 我们可以在一个 SQL 语句中放入另一个 SQL 语句。当我们在 WHERE 子句或 HAVING 子句中插入另一个 SQL 语句时，我们就有一个子查询 (subquery) 的架构。 子查询的作用是什么呢？第一，它可以被用来连接表。另外，有的时候子查询是唯一能够连接两个表格的方式。子查询的语法如下： SELECT “栏位1” FROM “表格” WHERE “栏位2” [ 比较运算素 ](SELECT “栏位1” FROM “表格” WHERE [ 条件 ]) [ 比较运算素 ] 可以是相等的运算素，例如 =, &gt;, &lt;, &gt;=, &lt;=. 这也可以是一个对文字的运算素，例如 “LIKE”。绿色的部分代表外查询，红色的部分代表内查询。 例如： 1SELECT SUM(Population) FROM city WHERE CountryCode IN (SELECT CountryCode FROM countrylanguage WHERE Language = "French"); EXISTS 上面的子查询中，我们用 IN 来连接内查询和外查询,而 EXISTS 也是这样一种方式。在 SQL 中 EXISTS 是用来测试内查询有没有产生任何结果。如果有的话，系统就会执行外查询中的 SQL。若是没有的话，那整个 SQL 语句就不会产生任何结果。EXISTS 的语法是： SELECT “栏位1” FROM “表格1” WHERE EXISTS (SELECT *FROM “表格2” WHERE [条件]) 例如： 1SELECT SUM(Population) FROM city WHERE EXISTS(SELECT * FROM countrylanguage WHERE Language = "French"); CASE CASE 是 SQL 用来做为 if-then-else 之类逻辑的关键字。 CASE 的语法如下： SELECT CASE (“栏位名”) WHEN “条件1” THEN “结果1” WHEN “条件2” THEN “结果2” … [ELSE “结果N”] END FROM “表格名” 注意： “条件” 可以是一个数值或是公式。 ELSE 子句则并不是必须的。 例如： 123456789SELECT NAME,CASE WHEN 'NanJing' THEN Population * 0.9WHEN 'TianShui' THEN Population * 1.1ELSE PopulationEND "New Population"FROM city; 说明： 练习 SQL 语句的数据库结构及数据 在这里。数据库管理系统使用的是 MySQL。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-内建数据类型]]></title>
    <url>%2Fblog%2F2017%2F02%2F17%2FPython-%E5%86%85%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[round()函数四舍六入五取偶 12345print(round(2.4),round(2.5),round(2.6))2 2 3print(round(-2.5),round(-2.5001),round(-2.6))-2 -3 -3 floor()向下取整、ceil()向上取整int()取整数部分正数且向下取整]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内嵌函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware-安装-ArchLinux]]></title>
    <url>%2Fblog%2F2017%2F02%2F14%2FVMware-%E5%AE%89%E8%A3%85-ArchLinux%2F</url>
    <content type="text"><![CDATA[一直听说ArchLinux挺不错，今天试着在虚拟机中安装一下，在这里跟大家分享一下经验。 ###准备工作ArchLinux镜像和VMware安装包ArchLinux镜像下载地址：http://mirrors.163.com/archlinux/iso/2018.07.01/我使用的是国内163的镜像网站，速度相对快一些。VMware 下载地址：https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html ###配置虚拟机VMware的具体安装这里不做赘述，相信大家都会安装。打开VMware，首先点击文件选项 -&gt; 新建虚拟机 -&gt; 典型 -&gt; 稍后安装操作系统 -&gt; 选择Linux选项 -&gt; 版本我选择的是‘Linux4.x’，内存分配1G就可以，硬盘分配20G左右就OK，根据自己需求来定。网络类型选择NAT，其他默认OK。CD/DVD选项记得选择ArchLinux镜像。 选择系统类型进入安装界面后出现下图中的启动选项，这里我选择第一个进行下一步操作 等待片刻后进入arch live os的终端命令行，默认root用户 ###测试网络状态archlinux整个安装过程中离不开网络，所以在安装之前测试网络尤为重要1# ping www.baidu.com 如果ping的结果找不到主机，可能是DHCP服务没有开启，可以使用如下命令开启1# systemctl dhcpcd.service 测试存储设备使用命令1# lsblk 命令查看一下存储设备状态。在sda节点下（准确的说是sdx，有几个设备就有几个sdx）看看有没有sda1这样的，每一个带数字的都是该物理硬盘分出来的区。依据我们刚才的设置，这里应该只有sda一个20G的硬盘。 ###硬盘分区下一步就是分区。我们使用cfdisk将sda分成一个mbr类型的分区。其他分区方式可以参考archwiki。输入1# cfdisk 进入交互界面。该工具使用非常简便，先new出分区，设置空间大小，然后改成bootable（也就是把那个星号打上）；再把分区信息write进去，最后quit即可。然后再使用1# lsblk 命令查看，会发现现在sda节点下已经多出了一个sda1，也就是我们刚刚分出来的分区。也可以使用fdisk命令对/dev/sda进行分区1# fdisk /dev/sda 具体操作大家自己学习学习fdisk命令哈。在这里，我就分了三个区。（用fdisk命令分的）/dev/sda1为根分区/dev/sda2为家目录的分区/dev/sda3为扩展分区/dev/sda5为交换分区 ###对分区格式化对于交换分区，格式化命令如下1# mkswap /dev/sda5 开启使用交换分区1# swapon /dev/sda5 格式化根分区和家目录分区12mkfs.ext4 /dev/sda1mkfs.ext4 /dev/sda2 根分区和家目录分区可格式化为其他文件系统，按自己需求格式化吧。 ###挂载各个分区 使用命令 1# mount /dev/sda1 /mnt 把根分区挂载在/mnt目录下再使用命令 1# mkdir /mnt/home 在/mnt目录下创建home目录，注意，如果你分了多个分区需要挂载boot，usr，opt目录等，均要在挂载完根目录后在/mnt目录下创建各个分区的目录。再进行挂载。使用命令 1# mount /dev/sda2 /mnt/home 挂载家目录 ###安装系统 挂载好分区之后，就可以安装arch了。但是第一件事情是先修改一下arch的镜像源，使用国内的镜像会得到更快的下载速度。修改镜像源需要编辑/etc/pacman.d/mirrorlist文件。1vi /etc/pacman.d/mirrorlist 我们利用正则表达式工具grep工具来将中国的源取出来。首先，先切换到软件源所在目录。1# cd /etc/pacman.d 然后用grep取出中国的源。用-A参数的话会用–分隔符分隔每一条匹配，因此再次使用grep工具去掉前一次结果产生的分隔符。1# grep -A 1 '##.*China' mirrorlist|grep -v '\-\-'&gt; mirrorlist2 最后将中国的源放到镜像源列表的最前面。这里先反过来，将原来的镜像源追加到中国的源后面，然后将追加完成之后的文件替换掉原来的镜像源。12# cat mirrorlist&gt;&gt;mirrorlist2# mv mirrorlist2 mirrorlist 镜像源修改完成之后需要刷新一下pacman的缓存。1# pacman -Syy 修改完镜像源，就可以开始安装基本系统了。pacman会从网络上下载最新的软件包开始安装。-i参数是在安装前进行确认，出现确认提示的话直接全选即可（一路enter）。12# pacstrap -i /mnt base base-devel​` 如果安装速度比较慢，那就稍微做点其他事等等吧。 ###配置新系统 安装完成系统之后需要生成fstab文件。生成之后需要查看一下是否生成成功。如果不成功需要重新生成。 12# genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab# nano /mnt/etc/fstab 进入新系统然后就可以进入新系统进行配置了。先进入新系统。 1# arch-chroot /mnt /bin/bash 进入新系统之后会发现命令提示符也发生了相应的变化。 ###配置新系统 安装完成系统之后需要生成fstab文件。生成之后需要查看一下是否生成成功。如果不成功需要重新生成。 12# genfstab -U -p /mnt &gt;&gt; /mnt/etc/fstab# nano /mnt/etc/fstab ###进入新系统 然后就可以进入新系统进行配置了。先进入新系统。 1# arch-chroot /mnt /bin/bash 进入新系统之后会发现命令提示符也发生了相应的变化。最后再重启下系统就OK了。图画界面没有试着去安装，这里就不做演示了。 `]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_买卖股票的最佳时机]]></title>
    <url>%2Fblog%2F2017%2F02%2F12%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536# 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。# 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。# 注意你不能在买入股票前卖出股票prices = [7, 1, 5, 3, 6, 4, 23, 21, 65, 23]class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ # 1. 暴力求解 O(n^2) # max = 0 # for i in range(0, len(prices)-1): # for j in range(i, len(prices)): # mxprofit = prices[j] - prices[i] # if mxprofit &gt; max: # max = mxprofit # return max # 2. O(n) minprices = max(prices) maxprices = 0 dayin, dayout = None, None for i in range(len(prices)): if prices[i] &lt; minprices: minprices = prices[i] dayin = i elif (prices[i] - minprices) &gt; maxprices: maxprices = prices[i] - minprices dayout = i return maxprices, dayin, dayout]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2Fblog%2F2017%2F02%2F05%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器（无参） （多装饰器执行由底向上）** 它是一个函数 函数作为它的形参 返回值也是一个函数 可以使用@functionname方式，简化调用 注：此处装饰器的定义只是简单总结，并不准确，只是方便理解 装饰器是高阶函数，但装饰器是对传入函数的功能的装饰（功能增强） 123456789101112131415161718192021222324252627import datetimeimport timedef logger(fn): def wrapper(*args,**kwargs): 'this is wrapper function' print('args=&#123;&#125;,kwargs=&#123;&#125;'.format(args,kwargs)) start = datetime.datetime.now() ret = fn(*args,**kwargs) duration = (datetime.datetime.now() - start).total_seconds() print('function &#123;&#125; took &#123;&#125;s'.format(fn.__name__,duration)) return ret return wrapper@loggerdef add(x, y): 'this is add function' return x + y&gt;&gt;&gt; add(5,5)&gt; args=(5, 5),kwargs=&#123;&#125;&gt; function add took 0.0s&gt;&gt;&gt; print(add.__name__)&gt;&gt;&gt; print(add.__doc__)&gt; wrapper&gt; this is wrapper function 上面的例子中我们会发现add函数对象的属性变成了wrapper函数的属性，使用装饰器我们是希望查看被封函数的属性，所以这里我们就需要带参装饰器来解决这个问题 带参装饰器 它是一个函数 函数作为它的形参 返回值是一个不带参数的装饰器函数 使用functionname(参数列表) 方式调用 可以看做在装饰外层又加了一层函数 需求：获取函数的执行时长，对时长超过阈(yu)值的函数记录一下 1234567891011121314151617181920212223242526272829303132333435import datetimeimport timedef copy_properties(src): def _copy(dest): dest.__name__ = src.__name__ dest.__doc__ = src.__doc__ return dest return _copydef logger(duration): def _logger(fn): @copy_properties(fn) # wrapper = copy_properties(fn)(wrapper) =&gt; _copy(wrapper) =&gt; wrapper def wrapper(*args,**kwargs): ''' this is wrapper function ''' start = datetime.datetime.now() ret = fn(*args,**kwargs) delta = (datetime.datetime.now() - start).total_seconds() print('so slow') if delta &gt; duration else print('so fast') return ret return wrapper return _logger@logger(6)def add(x, y): ''' this is add function ''' time.sleep(3) return x + y &gt;&gt;&gt; add(3,4)&gt;&gt;&gt; print(add.__doc__)&gt; so fast&gt; this is add function 注：这里我们通过copy_properties函数解决了上面属性发生改变的问题。 上面的例子我们还可以将记录功能提取出来，这样就可以通过外部提供的函数来灵活控制输出 123456789101112131415def logger(duration,func = lambda name,duration:print('&#123;&#125; took &#123;&#125;s'.format(name,duration))): def _logger(fn): @copy_properties(fn) # wrapper = copy_properties(fn)(wrapper) =&gt; _copy(wrapper) =&gt; wrapper def wrapper(*args,**kwargs): ''' this is wrapper function ''' start = datetime.datetime.now() ret = fn(*args,**kwargs) delta = (datetime.datetime.now() - start).total_seconds() if delta &gt; duration: func(fn.__name__,duration) return ret return wrapper return _logger #####在Python functools模块中自带了两个函数可以帮我们更方便的解决使用装饰器时函数属性改变的问题 update_wrapper函数 1functools.update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)) 类似copy_properties功能 wrapper 包装函数、被更新者、wrapped 被包装函数，数据源 元组WRAPPER_ASSIGNMENTS 中是要被覆盖的属性，模块名、名称、限定名、文档、参数注解 元组WRAPPER_UPDATES 中是要被更新的属性，dict 属性字典 增加一个wrapped属性，保留着wrapped函数 12345678910111213141516171819import datetime,time,functoolsdef logger(duration, func=lambda name,duration: print('&#123;&#125; took &#123;&#125;s'.format(name,duration))): def _logger(fn): def wrapper(*args,**kwargs): start = datetime.datetime.now() ret = fn(*args,**kwargs) delta = (datetime.datetime.now() - start).total_seconds() if delta &gt; duration: func(fn.__name__,duration) return ret return functools.update_wrapper(wrapper,fn) return _logger@logger(5) # add = logger(5)(add)def add(x,y): time.sleep(2) return x+yprint(add(5,6),add.__name__,add.__wrapped__,add.__dict__,sep='\n') wraps 函数 1functools.wraps(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)) 类似copy_properties功能 wrapped 被包装函数 元组WRAPPER_ASSIGNMENTS 中是要被覆盖的属性，模块名、名称、限定名、文档、参数注解 元组WRAPPER_UPDATES 中是要被更新的属性，dict 属性字典 增加一个wrapped属性，保留着wrapped函数 1234567891011121314151617181920import datetime,time,functoolsdef logger(duration, func=lambda name,duration: print('&#123;&#125; took &#123;&#125;s'.format(name,duration))): def _logger(fn): @functools.wraps(fn) def wrapper(*args,**kwargs): start = datetime.datetime.now() ret = fn(*args,**kwargs) delta = (datetime.datetime.now() - start).total_seconds() if delta &gt; duration: func(fn.__name__,duration) return ret return wrapper return _logger@logger(5) # add = logger(5)(add)def add(x,y): time.sleep(2) return x+yprint(add(5,6),add.__name__,add.__wrapped__,add.__dict__,sep='\n')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_有效的括号]]></title>
    <url>%2Fblog%2F2017%2F01%2F22%2F%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445# 给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串，判断字符串是否有效。# 有效字符串需满足：# 左括号必须用相同类型的右括号闭合。# 左括号必须以正确的顺序闭合。# 注意空字符串可被认为是有效字符串。from pythonds.basic.stack import Stackclass Solution: def isValid(self, s): """ :type s: str :rtype: bool """ if s == "": return True strs = '(&#123;[' st = list() balanced = True index = 0 opens = "(&#123;[" closes = ")&#125;]" while index &lt; len(s) and balanced: symbol = s[index] if symbol in strs: st.append(symbol) else: if len(st) == 0: balanced = False else: top = st.pop() if not (opens.index(top) == closes.index(symbol)): balanced = False # print(index, symbol, balanced) index += 1 if balanced and len(st) == 0: return True else: return False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发和并行的区别]]></title>
    <url>%2Fblog%2F2017%2F01%2F21%2F%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[## OK，如果你还在为并发（concurrency）和并行（parallelism）这两个词的区别而感到困扰，那么这篇文章就是写给你看的。搞这种词语辨析到底有什么意义？其实没什么意义，但是有太多人在混用错用这两个词（比如遇到的某门课的老师）。不论中文圈还是英文圈，即使已经有数不清的文章在讨论并行vs并发，却极少有能讲清楚的。让一个讲不清楚的人来解释，比不解释更可怕。比如我随便找了个网上的解释 前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生． 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。 并行(parallelism)是指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。 来个比喻：并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。 看了之后，你懂了么？不懂，更晕了。写出这类解释的人，自己也是一知半解，却又把自己脑子里模糊的影像拿出来写成文章，让读者阅毕反而更加疑惑。当然也有可能他确实懂了，但是写出这种文字也不能算负责。至于本文，请相信，一定是准确的，我也尽量做到讲解清晰。 OK，下面进入正题，concurrency vs parallelism 让我们大声朗读下面这句话： “并发”指的是程序的结构，“并行”指的是程序运行时的状态即使不看详细解释，也请记住这句话。下面来具体说说： 并行（parallelism）这个概念很好理解。所谓并行，就是同时执行的意思，无需过度解读。判断程序是否处于并行的状态，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，单线程永远无法达到并行状态。 要达到并行状态，最简单的就是利用多线程和多进程。但是 Python 的多线程由于存在著名的 GIL，无法让两个线程真正“同时运行”，所以实际上是无法到达并行状态的。 并发（concurrency）要理解“并发”这个概念，必须得清楚，并发指的是程序的“结构”。当我们说这个程序是并发的，实际上，这句话应当表述成“这个程序采用了支持并发的设计”。好，既然并发指的是人为设计的结构，那么怎样的程序结构才叫做支持并发的设计？ 正确的并发设计的标准是：使多个操作可以在重叠的时间段内进行(two tasks can start, run, and complete in overlapping time periods)。 这句话的重点有两个。我们先看“（操作）在重叠的时间段内进行”这个概念。它是否就是我们前面说到的并行呢？是，也不是。并行，当然是在重叠的时间段内执行，但是另外一种执行模式，也属于在重叠时间段内进行。这就是协程。 使用协程时，程序的执行看起来往往是这个样子： task1, task2 是两段不同的代码，比如两个函数，其中黑色块代表某段代码正在执行。注意，这里从始至终，在任何一个时间点上都只有一段代码在执行，但是，由于 task1 和 task2 在重叠的时间段内执行，所以这是一个支持并发的设计。与并行不同，单核单线程能支持并发。 经常看到这样一个说法，叫做并发执行。现在我们可以正确理解它。有两种可能： 原本想说的是“并行执行”，但是用错了词 指多个操作可以在重叠的时间段内进行，即，真的并行，或是类似上图那样的执行模式。 我的建议是尽可能不使用这个词，容易造成误会，尤其是对那些并发并行不分的人。但是读到这里的各位显然能正确区分，所以下面为了简便，将使用并发执行这个词。 第二个重点是“可以在重叠的时间段内进行”中的“可以”两个字。“可以”的意思是，正确的并发设计使并发执行成为可能，但是程序在实际运行时却不一定会出现多个任务执行时间段 overlap 的情形。比如：我们的程序会为每个任务开一个线程或者协程，只有一个任务时，显然不会出现多个任务执行时间段重叠的情况，有多个任务时，就会出现了。这里我们看到，并发并不描述程序执行的状态，它描述的是一种设计，是程序的结构，比如上面例子里“为每个任务开一个线程”的设计。并发设计和程序实际执行情况没有直接关联，但是正确的并发设计让并发执行成为可能。反之，如果程序被设计为执行完一个任务再接着执行下一个，那就不是并发设计了，因为做不到并发执行。 那么，如何实现支持并发的设计？两个字：拆分。 之所以并发设计往往需要把流程拆开，是因为如果不拆分也就不可能在同一时间段进行多个任务了。这种拆分可以是平行的拆分，比如抽象成同类的任务，也可以是不平行的，比如分为多个步骤。 并发和并行的关系 Different concurrent designs enable different ways to parallelize. 这句话来自著名的talk: Concurrency is not parallelism。它足够concise，以至于不需要过多解释。但是仅仅引用别人的话总是不太好，所以我再用之前文字的总结来说明：并发设计让并发执行成为可能，而并行是并发执行的一种模式。 最后，关于Concurrency is not parallelism这个talk再多说点。自从这个talk出来，直接引爆了一堆讨论并发vs并行的文章，并且无一例外提到这个talk，甚至有的文章直接用它的slide里的图片来说明。比如这张： 以为我要解释这张图吗？NO。放这张图的唯一原因就是萌萌的gopher。 再来张特写： 之前看到知乎上有个关于go为什么流行的问题，有个答案是“logo萌”当时我就笑喷了。 好像跑题了，继续说这个 talk。和很多人一样，我也是看了这个 talk 才开始思考 concurrency vs parallesim 的问题。为了研究那一堆推小车的 gopher 到底是怎么回事，我花费了相当多的时间。实际上后来我更多地是通过网上的只言片语（比如SO的回答）和自己的思考弄清了这个问题，talk 并没有很大帮助。彻底明白之后再回过头来看这个 talk，确实相当不错，Andrew Gerrand 对这个问题的理解绝对够深刻，但是太不新手向了。最大问题在于，那一堆 gopher 的例子不够好，太复杂。Andrew Gerrand 花了大把时间来讲述不同的并发设计，但是作为第一次接触这个话题的人，在没有搞清楚并发并行区别的情况下就去研究推小车的 gopher，太难了。“Different concurrent designs enable different ways to parallelize” 这句总结很精辟，但也只有那些已经透彻理解的人才能领会，比如我和看到这里的读者，对新手来说就和经文一样难懂。总结下来一句话，不要一开始就去看这个视频，也不要花时间研究推小车的gopher。Gopher is moe, but confusing. 最关键的一点是，计算机在不同层次上都使用了并行技术。之前我讨论的实际上仅限于 Task-Level 这一层，在这一层上，并行无疑是并发的一个子集。但是并行并非并发的子集，因为在 Bit-Level 和 Instruction-Level 上的并行不属于并发——比如引文中举的 32 位计算机执行 32 位数加法的例子，同时处理 4 个字节显然是一种并行，但是它们都属于 32 位加法这一个任务，并不存在多个任务，也就根本没有并发。 所以，正确的说法是这样：并行指物理上同时执行，并发指能够让多个任务在逻辑上交织执行的程序设计 按照我现在的理解，并发针对的是 Task-Level 及更高层，并行则不限。这也是它们的区别。 原文：https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_三数之和]]></title>
    <url>%2Fblog%2F2017%2F01%2F15%2F%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，# 使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。# 注意：答案中不可以包含重复的三元组。# 满足要求的三元组集合为：# [# [-1, 0, 1],# [-1, -1, 2]# ]nums = [-1, 0, 1, 2, -1, -4]class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums.sort() count = len(nums) collect = [] for i in range(count): left = i + 1 right = count - 1 # 避免重复找同一个数据 if i &gt; 0 and nums[i] == nums[i - 1]: left += 1 continue # 数据按小到大排列，每次选取nums[i]，在其后寻找符合a + b + c = 0的两个数据 while left &lt; right: sum = nums[i] + nums[left] + nums[right] if sum == 0: col = [nums[i], nums[left], nums[right]] collect.append(col) left += 1 right -= 1 # 循环中nums[i]已确定，当再确定1个数时，另一个数也确定，左右端任一端出现重复均可跳过 while nums[left] == nums[left - 1] and left &lt; right: left += 1 while nums[right] == nums[right + 1] and left &lt; right: right -= 1 if sum &lt; 0: left += 1 elif sum &gt; 0: right -= 1 return collect]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步-异步-阻塞-非阻塞-之间的关系]]></title>
    <url>%2Fblog%2F2017%2F01%2F14%2F%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[1. 同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。 换句话说，就是由调用者主动等待这个调用的结果。 而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。 典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。 2. 阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。 3. 同步阻塞、同步非阻塞、异步阻塞、异步非阻塞老张爱喝茶，废话不说，煮开水。出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 （1） 老张把水壶放到火上，立等水开。（同步阻塞）老张觉得自己有点傻 （2） 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）老张还是觉得自己有点傻， 于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 （3） 老张把响水壶放到火上，立等水开。（异步阻塞）老张觉得这样傻等意义不大 （4） 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；看电视的老张，非阻塞。情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>同步异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件系统层次结构标准(FHS)]]></title>
    <url>%2Fblog%2F2017%2F01%2F08%2F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86(FHS)%2F</url>
    <content type="text"><![CDATA[文件系统层次结构标准（英语：Filesystem Hierarchy Standard，FHS）定义了[Linux][操作系统]中的主要目录及目录内容。FHS由[Linux基金会]维护。 当前版本为3.0版，于2015年发布。 ####目录结构在FHS中，所有的文件和[目录] 都出现在根目录“/“下，即使他们存储在不同的物理设备中。但是请注意，这些目录中的一些可能或可能不会在Unix系统上出现，这取决于系统是否含有某些子系统，例如 X Window系统 的安装与否。这些目录中的绝大多数都在所有的UNIX操作系统中存在，并且一般都以大致类似的方法使用；然而，这里的描述是针对于FHS的，并未考虑除了Linux平台以外的权威性。| 目录 | 描述 || — | — || / | 第一层次结构 的根、 整个文件系统层次结构的[根目录]。 || /bin/ | 需要在[单用户模式]可用的必要命令（[可执行文件]）；面向所有用户，例如： cat、 ls、cp。 || /dev/ | 必要[设备], 例如：, /dev/null. || /etc/ | 特定主机，系统范围内的[配置文件]。关于这个名称目前有争议。在贝尔实验室关于UNIX实现文档的早期版本中，/etc 被称为etcetera，这是由于过去此目录中存放所有不属于别处的所有东西（然而，FHS限制/etc存放静态配置文件，不能包含二进制文件）。 自从早期文档出版以来，目录名称已被以各种方式重新称呼。最近的解释包括[反向缩略语]如：”可编辑的文本配置”（英文 “Editable Text Configuration”）或”扩展工具箱”（英文 “Extended Tool Chest”)。 || /home/ | 用户的[家目录]，包含保存的文件、个人设置等，一般为单独的分区。 || /lib/ | /bin/ 和 /sbin/中二进制文件必要的[库]文件。 || /media/ | 可移除媒体(如[CD-ROM]。 || /mnt/ | 临时[挂载]。 || /opt/ | 可选[应用软件]。 || /opt/ | 可选[应用软件]包。 || /proc/ | 虚拟[文件系统]，将[内核]与[进程]状态归档为文本文件。例如：uptime、 network。在Linux中，对应Procfs格式挂载。 || /root/ | [超级用户]的家目录。 || /sbin/ | 必要的系统二进制文件，例如： init、 ip、 mount。 || /srv/ | 站点的具体[数据]，由系统提供。 || /tmp/ | 临时文件(参见 /var/tmp)，在系统重启时目录中文件不会被保留。 || /usr/ | 用于存储只读用户数据的第二层次； 包含绝大多数的(多)用户工具和应用程序。 || /var/ | 变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区。 |]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>FHS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式简单总结]]></title>
    <url>%2Fblog%2F2017%2F01%2F04%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE）是由一类特殊字符及文本字符所编写的模式，其中有些字符（元字符）不表示字符字面意义，而表示控制或通配的功能。 程序支持：grep,sed,awk,vim, less,nginx,varnish等 分为两类：&ensp;&ensp;&ensp;&ensp;基本正则表达式：BRE&ensp;&ensp;&ensp;&ensp;扩展正则表达式：ERE，grep -E，egrep 正则表达式引擎：&ensp;&ensp;&ensp;&ensp;采用不同算法，检查处理正则表达式的软件模块&ensp;&ensp;&ensp;&ensp;PCRE（Perl Compatible Regular Expressions） 元字符分类：字符匹配、匹配次数、位置锚定、分组 ##基本正则表达式元字符 ####字符匹配: . 匹配任意单个字符 [] 匹配指定范围内的任意单个字符 [^] 匹配指定范围外的任意单个字符 [:alnum:] 字母和数字 [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:lower:] 小写字母 [:upper:] 大写字母 [:blank:] 空白字符（空格和制表符） [:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广） [:cntrl:] 不可打印的控制字符（退格、删除、警铃...） [:digit:] 十进制数字 [:xdigit:]十六进制数字 [:graph:] 可打印的非空白字符 [:print:] 可打印字符 [:punct:] 标点符号 ####匹配次数用在要指定次数的字符后面，用于指定前面的字符要出现的次数 * 匹配前面的字符任意次，包括0次 贪婪模式：尽可能长的匹配 .* 任意长度的任意字符 \? 匹配其前面的字符0或1次 + 匹配其前面的字符至少1次 {n} 匹配前面的字符n次 {m,n} 匹配前面的字符至少m次，至多n次 {,n} 匹配前面的字符至多n次 {n,} 匹配前面的字符至少n次 ####位置锚定：定位出现的位置 ^ 行首锚定，用于模式的最左侧 $ 行尾锚定，用于模式的最右侧 ^PATTERN$ 用于模式匹配整行 ^$ 空行 ^[[:space:]]*$ 空白行 \&lt; 或 \b 词首锚定，用于单词模式的左侧 \&gt; 或 \b 词尾锚定；用于单词模式的右侧 \&lt;PATTERN\&gt; 匹配整个单词 ####分组() 将一个或多个字符捆绑在一起，当作一个整体进行处理，如：(root)+分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为: \1, \2, \3, … \1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符 示例： \(string1\+\(string2\)\*) \1 ：string1+\(string2\)* \2 ：string2 ####后向引用引用前面的分组括号中的模式所匹配字符，而非模式本身或者：| 示例：a|b: a 或 b C|cat: C 或 cat (C|c)at : Cat 或 cat ####egrep及扩展的正则表达式 egrep = grep -Eegrep [OPTIONS] PATTERN [FILE…] 扩展正则表达式的元字符： 字符匹配： . 任意单个字符 [] 指定范围的字符 [^] 不在指定范围的字符 次数匹配： *：匹配前面字符任意次 ?: 0或1次 +：1次或多次 {m}：匹配m次 {m,n}：至少m，至多n次 位置锚定： ^ :行首 $ :行尾 &lt;, \b :语首 &gt;, \b :语尾 分组： () 后向引用：\1, \2, ... 或者： a|b: a或b C|cat: C或cat (C|c)at:Cat或cat]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fblog%2F2017%2F01%2F03%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[元字符 \ba\w\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w)，最后是单词结束处(\b)。 \d+匹配1个或更多连续的数字。这里的+是和类似的元字符，不同的是匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。 \b\w{6}\b 匹配刚好6个字符的单词。 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。 字符转义 如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和。当然，要查找\本身，你也得用. 重复 下面是正则表达式中所有的限定符(指定数量的代码，例如*,{5,12}等)： 下面是一些使用重复的例子： Windows\d+匹配Windows后面跟1个或更多数字 ^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 分组 上面提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。 (\d{1,3}.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。 不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。 理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。 反义 有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义： 例子：\S+匹配不包含空白符的字符串。 &lt;a&gt;+&gt;匹配用尖括号括起来的以a开头的字符串。 后向引用 后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例： \b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。 也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k,所以上一个例子也可以写成这样：\b(?\w+)\b\s+\k\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些： 零宽断言 接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧： (?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I’m singing while you’re dancing.时，它会匹配sing和danc。 (?&lt;=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?&lt;=\d)\d{3})+\b，用它对1234567890进行查找时结果是234567890。 下面这个例子同时使用了这两种断言：(?&lt;=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。 负向零宽断言 前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词–它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样： \b\wqu\w\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为u总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的u将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w\b将会匹配下一个单词，于是\b\wqu\w\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\wq(?!u)\w*\b。 零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 同理，我们可以用(?&lt;!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?&lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。 一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是)，然后是.(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是的话，后缀就是了。整个表达式匹配的是和之间的内容(再次提醒，不包括前缀和后缀本身)。 贪婪与懒惰 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 参考： https://deerchao.net/tutorials/regex/regex.htm#mission]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原码 反码 补码 位运算符]]></title>
    <url>%2Fblog%2F2016%2F12%2F28%2F%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[原码原码是电脑运算的名词，是指“未经更改”的码。为了便于ALU（算术逻辑单元）的设计，又发展出反码、补码等转换过的码。 原码是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。 计算机中所有的数均用0、1编码表示，数字的正负号也不例外，如果一个机器数字长是n位的话，约定最左边一位用作符号位，其余n-1位用于表示数值。 原码是最简单的编码方式，便于输入输出，但作为代码加减运算时较为复杂。一个字长为n的机器数能表示不同的数字的个数是固定的2^n个。当 n=8时，能表示256个数字。 有符号数： 用来表示有符号数，数的范围就是 -(2^{n-1}-1)~ +(2^{n-1}-1)} 。当n=8时，这个范围就是 -127~ +127。 无符号数： 在不需要考虑数的正负时，就不需要用一位来表示符号位，n位机器数全部用来表示是数值，这时表示数的范围就是 0 ~ 2^{n}-1。当 n=8时，这个范围就是 0~ 255。 原码的优点： 简单直观，我们用8位二进制表示一个数，则+11的原码为00001011，-11的原码就是10001011。 ​ 5 =&gt; 0b101, 1 =&gt; 0b1, -1=&gt; -0b1 原码的缺点： 原码不能直接参加运算，可能会出错。例如数学上，1+(-1)=0，而在二进制中00000001+10000001=10000010，换算成十进制为-2。显然出错了。 所以原码的符号位不能直接参与运算，必须和其他位分开，这就增加了硬件的开销和复杂性。 反码将二进制数反转，得到的数即为原二进制的反码（ones’ complement）。若某一位为0，则使其变为1，反之亦然。 一个数的反码在很多算术运算中的表现与这个数的相反数很相似，此特性可使加法电路同时可以运算减法。然而，由于反码中存在多余的负零和其它问题，反码并未像补码一样被广泛应用。 ​ 正数的反码与原码相同；负数的反码符号位不变其余取反 例如，+3是0011，用反码表示-3便是1100。 下表列出了4-bit二进数所能表示的整数。]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-列表解析式-生成器表达式]]></title>
    <url>%2Fblog%2F2016%2F12%2F03%2FPython-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F---%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[列表解析式 语法 [ 返回值 for 元素 in 可迭代对象 if 条件 ] 使用中括号[]，内部是for循环，if 条件语句可选 返回一个新的列表 列表解析式是一种语法糖 编译器会优化，不会因为简写而简写影响效率，反而因优化提高了效率 减少程序员工作量，减少出错 简化了代码，但可读性增强 生成器表达式 语法 ( 返回值 for 元素 in 可迭代对象 if 条件 ) 列表解析式的中括号换成小括号()就行了 返回一个生成器 和列表解析式的区别 生成器表达式是按需求计算（或称惰性求值、延迟计算），需要的时候才计算值 列表解析式是立即返回值 计算方式 生成器（延迟计算、返回迭代器、从前到后走完一遍，不能回头） 列表解析式（立即计算、返回的不是迭代器，返回可迭代对象列表，从前到后走完一遍后，可以重新回头迭代） 内存占用 单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表 生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多 列表解析式构造新的列表需要占用内存 计算速度 单看计算时间，生成器表达式耗时非常短，列表解析式耗时长 但是生成器本身并没有返回任何值，只返回了一个生成器对象 列表解析式构造并返回了一个新的列表 生成器 可迭代对象 迭代器 生成器和迭代器是不同的对象，但是都是可迭代对象！！！集合解析式类似列表解析式，使用花括号{}即可 字典解析式 {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}即可 使用key.value形式 立即返回一个字典]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2Fblog%2F2016%2F10%2F21%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP协议 互联网协议（英语：Internet Protocol Suite，缩写IPS）[1]是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP[2]。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准[3]。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack）[4][5] 。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）[6]。这个协议族由互联网工程任务组负责维护。TCP/IP提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化)为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中[7][8]，常被视为是简化的七层OSI模型。 因特网协议栈中的层 通常人们认为OSI模型的最上面三层（应用层、表示层和会话层）在TCP/IP组中是一个应用层。由于TCP/IP有一个相对较弱的会话层，由TCP和RTP下的打开和关闭连接组成，并且在TCP和UDP下的各种应用提供不同的端口号，这些功能能够被单个的应用程序（或者那些应用程序所使用的库）增加。与此相似的是，IP是按照将它下面的网络当作一个黑盒子的思想设计的，这样在讨论TCP/IP的时候就可以把它当作一个独立的层。 应用层该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议。 应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。在传输层，应用程序最常用的是TCP或者UDP，并且服务器应用程序经常与一个公开的端口号相联系。服务器应用程序的端口由互联网号码分配局（IANA）正式地分配，但是现今一些新协议的开发者经常选择它们自己的端口号。由于在同一个系统上很少超过少数几个的服务器应用，端口冲突引起的问题很少。应用软件通常也允许用户强制性地指定端口号作为运行参数。 传输层传输层（transport layer）的协议，能够解决诸如端到端可靠性（“数据是否已经到达目的地？”）和保证数据按照正确的顺序到达这样的问题。在TCP/IP协议组中，传输协议也包括所给数据应该送给哪个应用程序。 在TCP/IP协议组中技术上位于这个层的动态路由协议通常被认为是网络层的一部分； TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。这是它与UDP不同之处，这在实时数据流或者路由高网络层丢失率应用的时候可能成为一个缺陷。 较新的SCTP也是一个“可靠的”、面向链接的传输机制。它是面向纪录而不是面向字节的，它在一个单独的链接上提供通过多路复用提供的多个子流。它也提供多路自寻址支持，其中链接终端能够被多个IP地址表示（代表多个实体接口），这样的话即使其中一个连接失败了也不中断。它最初是为电话应用开发的（在IP上传输SS7），但是也可以用于其他的应用。 UDP（IP协议号17）是一个无链接的数据报协议。它是一个“尽力传递”（best effort）或者说“不可靠”协议——不是因为它特别不可靠，而是因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。如果一个应用程序需要这些特性，那它必须自行检测和判断，或者使用TCP协议。 UDP的典型性应用是如流媒体（音频和视频等）这样按时到达比可靠性更重要的应用，或者如DNS查找这样的简单查询／响应应用，如果创建可靠的链接所作的额外工作将是不成比例地大。 网络互连层TCP/IP协议族中的网络互连层（internet layer）在OSI模型中叫做网络层（network layer）。 正如最初所定义的，网络层解决在一个单一网络上传输数据包的问题。类似的协议有X.25和ARPANET的Host/IMP Protocol。 随着因特网思想的出现，在这个层上添加附加的功能，也就是将数据从源网络传输到目的网络。这就牵涉到在网络组成的网上选择路径将数据包传输，也就是因特网。 在因特网协议组中，IP完成数据从源发送到目的的基本任务。IP能够承载多种不同的高层协议的数据；这些协议使用一个唯一的IP协议号进行标识。ICMP和IGMP分别是1和2。 一些IP承载的协议，如ICMP（用来发送关于IP发送的诊断信息）和IGMP（用来管理多播数据），它们位于IP层之上但是完成网络层的功能，这表明因特网和OSI模型之间的不兼容性。所有的路由协议，如BGP、OSPF、和RIP实际上也是网络层的一部分，尽管它们似乎应该属于更高的协议栈。 ####网络接口层网络接口层实际上并不是因特网协议组中的一部分，但是它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。这个过程能够在网卡的软件驱动程序中控制，也可以在韧体或者专用芯片中控制。这将完成如添加报头准备发送、通过实体介质实际发送这样一些数据链路功能。另一端，链路层将完成数据帧接收、去除报头并且将接收到的包传到网络层。 然而，链路层并不经常这样简单。它也可能是一个虚拟专有网络（VPN）或者隧道，在这里从网络层来的包使用隧道协议和其他（或者同样的）协议组发送而不是发送到实体的接口上。VPN和信道通常预先建好，并且它们有一些直接发送到实体接口所没有的特殊特点（例如，它可以加密经过它的数据）。由于现在链路“层”是一个完整的网络，这种协议组的递归)使用可能引起混淆。但是它是一个实现常见复杂功能的一个优秀方法。（尽管需要注意预防一个已经封装并且经隧道发送下去的数据包进行再次地封装和发送）。 IP网络如何并吞竞争的网络在长期的发展过程中，IP逐渐取代其他网络。这里是一个简单的解释。IP传输通用数据。数据能够用于任何目的，并且能够很轻易地取代以前由专有数据网络传输的数据。下面是一个普通的过程： 一个用于特定目的所开发出来的网络。如果它顺利工作，用户将能使用它。 为了提供便利的IP服务，经常用于访问电子邮件或者聊天，通常以某种方式通过专有网络隧道实现。隧道方式最初可能非常没有效率，因为电子邮件和聊天只需要很低的带宽。 通过一点点的投资IP基础设施逐渐在专有数据网络周边出现。 用IP取代专有服务的需求出现，经常是一个用户要求。 IP替代品过程遍布整个因特网，这使IP替代品比最初的专有网络更加有价值（由于网络效应）。 专有网络受到压制。许多用户开始维护使用IP替代品的复制品。 IP包的间接开销很小，少于1%，这样在成本上非常有竞争性。人们开发一种能够将IP带到专有网络上的大部分用户的不昂贵的传输介质。 大多数用户为了削减开销，专有网络被取消。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_两数之和]]></title>
    <url>%2Fblog%2F2016%2F10%2F13%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930# 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。# 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。# 示例:# 给定 nums = [2, 7, 11, 15], target = 9# 因为 nums[0] + nums[1] = 2 + 7 = 9# 所以返回 [0, 1]nums = [2, 7, 11, 15]# nums = [3,2,4]target = 18class Solution: def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ nums.sort() d = &#123;&#125; for i in range(len(nums)): d[nums[i]] = i for i in range(len(nums)): complement = target - nums[i] if complement in d.keys() and i != d[complement]: return [nums[i], complement]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题]]></title>
    <url>%2Fblog%2F2016%2F10%2F05%2FPython-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[打印菱形12345678910111213 * *** ************ ***** *** *n = 7e = -(n//2)for i in range(e,n+e): print(&apos; &apos;*abs(i)+&apos;*&apos;*(n-2*abs(i))) 123456789101112 * * * * ** * * * * * *n = 7e = n//2for i in range(-e,n-e): print(&apos; &apos;*abs(i)+(&apos;*&apos;+( &apos; &apos;*(n-2*abs(i)-2) if (n-2*abs(i)) &gt; 1 else &apos;&apos;)+(&apos;&apos; if (n-2*abs(i)) == 1 else &apos;*&apos;))) 1234567891011121314******* ***** *** * *** ************n = 7e = n//2for i in range(-e,n-e): prespace = -i if i &lt; 0 else i print(&apos; &apos;*(e - prespace)+&apos;*&apos;*(2*prespace+1)) 1234567891011121314151617181920212223242526 * ** ********** *** ** *n = 7e = -(n//2)for i in range(e,n+e): if i &lt; 0: print(&apos; &apos;*abs(i)+&apos;*&apos;*(abs(-n//2 - i))) elif i &gt; 0: print(&apos; &apos;*abs(e)+&apos;*&apos;*(abs(-n//2 + i))) else: print(&apos;*&apos;*n)for i in range(-3,4): if i &lt; 0 : print(&apos; &apos;*(-i)+&apos;*&apos;*(4+i)) elif i &gt; 0: print(&apos; &apos;*3+&apos;*&apos;*(4-i)) else: print(&apos;*&apos;*7) 打印直角三角1234567891011 ***** **** *** ** *def triangle(): for i in range(5): for i in range(5-i): print(&apos;*&apos;,end=&apos;&apos;) print() 打印等边三角形12345678910 * *** ***** *******n=5j=1for i in range(n-1,0,-1): print(&apos; &apos;*i+&apos;*&apos;*j) j+=2 打印100以内的斐波那契数列12345678910111213141516171819202122232425262728293031a = 0b = 1print(a,b,end=&apos; &apos;)while True: s = a+b if s &gt; 100: break print(s,end=&apos; &apos;) a,b = b,s#==========================def fib(n): if n == 0: return 0 elif n==1: return 1 else: return fib(n-1) + fib(n-2)print(fib(100))#==========================def fib(n): for i in range(n): a,b = 0,1 while n&gt;0: yield b a,b = b,a+b n -= 1print(list(fib(100))) 求10万内的所有素数12345678910count = 1for i in range(3,100000,2): if i &gt; 10 and i % 10 == 5: continue for j in range(3,int(i**0.5)+1,2): if i % j == 0: break else: count += 1 print(i,count,end=&apos; &apos;) # 9592 猴子吃桃问题猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第十天早上在想吃时，就只剩一个桃子了。求第一天共摘了多少个桃子？ 1234peach = 1for i in range(9): peach = (peach+1)*2print(peach) 打印九九乘法表1234567891011121314151*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 for i in range(1,10): for j in range(1,i+1): print(&apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;&apos;.format(j,i,i*j,2 if j&lt;2 else 3),end=&apos;&apos;) print() 12345678910111213141516171819 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 6*6=36 6*7=42 6*8=48 6*9=54 7*7=49 7*8=56 7*9=63 8*8=64 8*9=72 9*9=81for i in range(1,10): line = &apos;&apos; for j in range(i,10): line += &apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;&#123;&#125;&#125;&apos;.format(i,j,i*j,3 if j &lt; 4 else 4) print(&apos;&#123;:&gt;70&#125;&apos;.format(line)) 123456789101112131415161*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 6*6=36 6*7=42 6*8=48 6*9=54 7*7=49 7*8=56 7*9=63 8*8=64 8*9=72 9*9=81 for i in range(1,10): for j in range(i,10): print(&apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;4&#125;&apos;.format(i,j,i*j),end=&apos;&apos;) print() 12345678910111213141516 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81for i in range(1,10): line = &apos;&apos; for j in range(1,i+1): line += &apos;&#123;&#125;*&#123;&#125;=&#123;:&lt;4&#125;&apos;.format(i,j,i*j) print(&apos;&#123;:&gt;75&#125;&apos;.format(line)) ​]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_QuickSort]]></title>
    <url>%2Fblog%2F2016%2F09%2F16%2FQuickSort%2F</url>
    <content type="text"><![CDATA[12345678910111213141516origin = [30, 20, 80, 40, 50, 10, 60, 70, 90]def quicksort(array): if len(array) &lt; 2: return array else: midpivot = array[0] lessbeforemidpivot = [i for i in array[1:] if i &lt;= midpivot] biggerafterpivot = [i for i in array[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot) + [midpivot] + quicksort(biggerafterpivot) return finallylistprint(quicksort(origin))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题_HeapSort]]></title>
    <url>%2Fblog%2F2016%2F09%2F10%2FHeapSort%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647origin = [30, 20, 80, 40, 50, 10, 60, 70, 90]origin = [0] + origin# 堆调整def heap_adjust(n, i, array): while 2 * i &lt;= n: lchild_index = 2 * i max_index = lchild_index if n &gt; lchild_index and array[lchild_index + 1] &gt; array[lchild_index]: max_index = lchild_index + 1 if array[max_index] &gt; array[i]: array[i], array[max_index] = array[max_index], array[i] i = max_index else: breaktotal = len(origin) - 1index = total // 2# 构建大顶堆def max_heap(n, array): for i in range(n // 2, 0, -1): heap_adjust(n, i, array) return arraymax_heap(total, origin)# 排序def sort(n, array): while n &gt; 1: array[n], array[1] = array[1], array[n] n -= 1 if n == 2 and array[total] &gt; array[total - 1]: break heap_adjust(n, 1, array) return arrayprint(sort(total, origin))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现杨辉三角]]></title>
    <url>%2Fblog%2F2016%2F07%2F07%2F%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[方法一：1234567891011lst = [[1]]n = 6for i in range(1,n-1): if i == 1: lst.append([1,1]) newlst = [1] for j in range(i): newlst.append(lst[-1][j]+lst[-1][j+1]) newlst.append(1) lst.append(newlst)print(lst) 方法 二：1234567891011pre = [1]print(pre)n = 6for i in range(1,n): newlst = [] # pre.insert(0, 0) pre.append(0) for j in range(i+1): newlst.append(pre[j-1]+pre[j]) print(newlst) pre = newlst 方法 三：1234567891011triangle = []n = 6for i in range(n): row = [1]*(i+1) triangle.append(row) for j in range(1,i//2+1): val = triangle[i-1][j-1] + triangle[i-1][j] row[j]=val if i!=2*j: row[-j-1] = valprint(triangle)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT笔记]]></title>
    <url>%2Fblog%2F2016%2F06%2F26%2Fgit-%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。 林纳斯·托瓦兹自嘲地取了这个名字“git”，该词源自英国俚语，意思大约是“混账”。 I&#39;m an egotistical bastard, and I name all my projects after myself. First Linux, now git. 实现原理 git更像一个文件系统，直接在本机上获取数据，不必连线到主机端获取数据。 每个开发者都可有全部开发历史的本地副本，changes从这种本地repository复制给其他开发者。这些changes作为新增的开发分支被导入，可以与本地开发分支合并。 分支是非常轻量级的，一个分支仅是对一个commit的引用。 git是用C语言开发的，以追求最高的性能。git自动完成垃圾回收，也可以用命令git gc --prune直接调用。 git存储每个新创建的object作为一个单独文件。为了压缩存储空间占用， packs操作把很多文件（启发式类似名字的文件往往具有类似内容）使用差分压缩入一个文件中（packfile），并创建一个对应的索引文件，指明object在packfile中的偏移值。新创建的对象仍然作为单独文件存在。repacks操作非常费时间，git会在空闲时间自动做此操作。也可用命令git gc来直接启动repack。packfile与索引文件都用SHA-1作为校验和并作为文件名。git fsck命令做校验和的完整性验证。 Git服务器典型的TCP 监听端口为9418。 库目录 hooks：存储钩子的文件夹 logs：存储日志的文件夹 refs：存储指向各个分支的指针（SHA-1标识）文件 objects：存放git对象 config：存放各种设置文档 HEAD：指向当前所在分支的指针文件路径，一般指向refs下的某文件 基本概念 我们先来理解下Git 工作区、暂存区和版本库概念 工作区 (working directory)：就是你在电脑里能看到的目录。 暂存区 (staging index)：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库 (git diretory[Repository])：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git 安装git 支持windows、MAC OS X、Linux/Unix 全平台windows/Mac 官网下载：https://www.git-scm.com/download/Ubantu：sudo apt-get install gitCentOS：sudoyum install git检查是否安装成功：git --version 查看git版本 Git基本命令 git init 初始化本地git仓库（执行命令所在的目录下出现 .git 文件） git add git add filename 将文件添加到暂存区 git add . 将工作目录下的所有修改的文件添加到暂存区 git commit git commit -m &#39;description&#39; 将暂存区的文件提交到版本库 git commit -am &#39;description&#39; 跳过git add 添加到暂存区命令，直接将工作区所有已跟踪的文件提交 git log 显示所有提交操作log git log --oneline 将所有提交信息在一行内显示 git log -1 -p -p显示修改内容 gik 图形化显示日志信息 git log --oneline --grap git status 查看项目文件状态 git config git config --global user.name test 添加用户身份象征username git config --global user.email 123456@qq.com添加用户邮箱 git config --lsit 查看配置信息 ~/.gitconfig 配置文件位置 Git状态 git 中文件的4种文件状态 Untracked 未被追踪 Modified 表示工作区修改了某个文集但是还没有添加到暂存区 Staged 表示把工作区修改的文件添加到了暂存区但是还没有提交到版本库 Committed 表示数据安全的存储在本地库中 Git撤销操作 git commit --amend 撤销上一次提交并将暂存区的文件重新提交 git checkout --filename 拉取暂存区的文件并将其替换工作区的文件 git reset HEAD filename 拉取最近一次提交的版本库中的这个文件到暂存区，该操作不影响工作区 git reset --option 版本号 --hard 回退暂存区和工作区到指定版本号 --mixed 回退版本库和暂存区到指定版本号 --soft 只回退版本库到指定版本 Git 文件删除 git rm filename 删除工作区及暂存区中的该文件相当于删除后执行git add git rm --cached filename 在不小心将不需要追踪的文件添加到暂存区，想删除暂存的文件但是不想删除工作区的文件 git rm -f filename 当工作区或者暂存区文件修改了（防止修改误删除了） giob模式 星号（*）匹配零个或多个任意字符 [abc] 匹配任何一个列在方括号中的字符 问号（?）只匹配一个任意字符 [0-9] 、[a-z] 匹配范围 git mv oldname newname 相当于 mv oldname newname git rm oldname git add newname git 分支的创建、删除、切换、删除 git branch 查看分支 git branch branchname创建分支 git branch -m oldname newname 修改分支名称 git checkout [-b] branchname 切换分支 git branch -D branchname删除分支 分支的合并 分支的指针 HEAD指针指向当前工作的分支 在切换分支是指向新的分支 git diff git diff 比较工作区与暂存区文件的差异 git diff --staged 比较暂存区与版本库的文件差异 git diff 版本号 版本号比较分支内的两个版本的差异 git diff 分支 分支 比较两个分支的最新提交版本的差异 git merge branchname 合并之前需要先切换到master分支，快速合并和冲突合并 存储变更 git stash git stash list git stash apply stash@num git stash apply 后面不加名字，则应用最近一次存储信息 git stash drop stash@num git stash apply 只是运用存储的信息，并不删除它，drop 命令可以删除它 Github上的仓库 创建github账号 创建仓库 clone仓库到本地 本地push到仓库 pull代码到本地 ignoing files 想忽略不想被追踪的文件，只需要将文件名字添加到.gitignore文件内，Git就会自动忽略这些文件 fork and pull request 远程服务器上的仓库 git init --bare 创建远端仓库（在服务器或者工程目录以外路径都可以创建的备份仓库） git remote 查看当前配置了哪些远程仓库 git remote add name path 要添加一个新的远程仓库，可以指定一个简单的名字 git remote rm name 删除远程仓库 git remote rename oldname newname 重命名远程仓库名 git fetch 从远程仓库下载新分支与数据 ，该命令执行完后需要执行git merge 远程分支到你所在的分支。 Git ssh免密登录 ssh-kegen ssh-copy-id user@host 将本机的公钥复制到远程服务器的authorized_key文件中 如果不是自己的服务器可以将本地公钥发给服务器管理员 添加在authorized_keys文件后面]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
